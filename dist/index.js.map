{"version":3,"sources":["webpack://view-image-size/./build/detectImageType.js","webpack://view-image-size/./build/firstBytes.js","webpack://view-image-size/./build/imageSize.js","webpack://view-image-size/./build/index.js","webpack://view-image-size/./build/isTiffBigEndian.js","webpack://view-image-size/./build/lookup.js","webpack://view-image-size/./build/readUInt.js","webpack://view-image-size/./build/toHexadecimal.js","webpack://view-image-size/./build/types/bmp.js","webpack://view-image-size/./build/types/cur.js","webpack://view-image-size/./build/types/dds.js","webpack://view-image-size/./build/types/gif.js","webpack://view-image-size/./build/types/icns.js","webpack://view-image-size/./build/types/ico.js","webpack://view-image-size/./build/types/isEXIFAppMarker.js","webpack://view-image-size/./build/types/j2c.js","webpack://view-image-size/./build/types/jp2.js","webpack://view-image-size/./build/types/jpg.js","webpack://view-image-size/./build/types/ktx.js","webpack://view-image-size/./build/types/png.js","webpack://view-image-size/./build/types/pnm.js","webpack://view-image-size/./build/types/psd.js","webpack://view-image-size/./build/types/readJpgBlockLength.js","webpack://view-image-size/./build/types/specificHandlers.js","webpack://view-image-size/./build/types/svg.js","webpack://view-image-size/./build/types/tiff.js","webpack://view-image-size/./build/types/tiffHelpers.js","webpack://view-image-size/./build/types/typeHandlers.js","webpack://view-image-size/./build/types/validateJPG.js","webpack://view-image-size/./build/types/webp.js","webpack://view-image-size/./build/viewTiffImage.js","webpack://view-image-size/webpack/bootstrap","webpack://view-image-size/webpack/startup"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","firstBytes_js_1","typeHandlers_js_1","specificHandlers_js_1","default","view","toAscii","found","handleType","byte","getUint8","byteType","validate","undefined","detectionByFirstByte","i","specificHandlers","length","key","loopThruSpecificHandlers","keys","lookup_js_1","detectImageType_js_1","Error","type","isTiffBigEndian","viewTiffImage","detectImageType","imageSize","imageSize_js_1","enumerable","get","viewTiffImage_js_1","isTiffBigEndian_js_1","offset","signature","TypeError","size","calculate","readUInt32LE","readUInt32BE","readUInt32","readUInt16LE","readUInt16BE","readUInt16","readUInt24LE","readInt32LE","readInt16LE","getInt16","getInt32","getUint32","isBigEndian","getUint16","begin","end","output","toString","padStart","BMP","readUInt_js_1","buffer","height","Math","abs","width","CUR","ico_js_1","ICO","DDS","GIF","gifRegexp","test","ICNS","ICON_TYPE_SIZE","ICON","icm4","icm8","ics4","ics8","is32","s8mk","icp4","icl4","icl8","il32","l8mk","icp5","ic11","ich4","ich8","ih32","h8mk","icp6","ic12","it32","t8mk","ic07","ic08","ic13","ic09","ic14","ic10","readImageHeader","imageOffset","imageLengthOffset","getImageSize","bufferLength","byteLength","fileLength","imageHeader","result","images","push","getSizeFromOffset","imageIndex","nbImages","imgs","shortMarker","identifierHi","identiferLo","compareEXIFIdentifier","J2C","toHexadecimal_js_1","JP2","parseIHDR","box","signatureLength","ftypeBoxStart","unit","calculateRREQLength","JPG","validateJPG_js_1","readJpgBlockLength_js_1","isEXIFAppMarker_js_1","extractSize","index","validateExifBlock","byteAlign","exifBlock","idfDirectoryEntries","directoryEntryNumber","start","blockStart","extractOrientation","validateBuffer","orientation","markerOffset","blockLength","headerOffset","KTX","PNG","pngFriedChunkName","chunkName","PNM","PNMTypes","P1","P2","P3","P4","P5","P6","P7","PF","Signatures","handlers","lines","dimensions","line","shift","split","parseInt","pam","charCodeAt","toLowerCase","includes","PSD","SVG","svgReg","extractorRegExps","root","viewbox","INCH_CM","units","in","cm","em","ex","m","mm","pc","pt","px","unitsReg","RegExp","join","parseLength","len","exec","round","Number","parseViewbox","bounds","toUtf8String","TextDecoder","decode","str","match","attrs","parseAttributes","calculateByDimensions","ratio","floor","calculateByViewbox","TIFF","tiffHelpers_js_1","signatures","fileSignature","initialLocation","getIdfOffsetLocation","tags","nextOffset","getIdfOffset","noOfEntries","getNoOfIdfEntries","beginIndexForIdf","endIndexForIdf","stride","getStrideForIdf","extractIdfEntry","intoResult","TIFF_IDF_ENTRY_STRIDE","TIFF_IDF_OFFSET_SIZE","TIFF_IDF_COUNT_STRIDE","directoryOffset","code","valueFieldOffset","bmp_js_1","cur_js_1","dds_js_1","gif_js_1","icns_js_1","j2c_js_1","jp2_js_1","jpg_js_1","ktx_js_1","png_js_1","pnm_js_1","psd_js_1","svg_js_1","tiff_js_1","webp_js_1","typeHandlers","bmp","cur","dds","gif","icns","ico","j2c","jp2","jpg","ktx","png","pnm","psd","svg","tiff","webp","WEBP","riffHeader","webpHeader","vp8Header","chunkHeader","extendedHeader","validEnd","calculateExtended","calculateLossy","sampleStart","calculateLossless","moveToIdfCount","pos","adjust","readIdfCount","initLocation","LOCAL_OFFSET","count","location","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst firstBytes_js_1 = __importDefault(require(\"./firstBytes.js\"));\nconst typeHandlers_js_1 = __importDefault(require(\"./types/typeHandlers.js\"));\nconst specificHandlers_js_1 = require(\"./types/specificHandlers.js\");\n/**\n * detect the image type\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {imageType | undefined} - returns image type (as string)\n **/\nfunction detectImageType(view, toAscii) {\n    const detectionByFirstByte = () => {\n        const byte = view.getUint8(0);\n        if (byte in firstBytes_js_1.default) {\n            const byteType = firstBytes_js_1.default[byte];\n            if (byteType && typeHandlers_js_1.default[byteType].validate(view, toAscii)) {\n                return [true, byteType];\n            }\n        }\n        return [false, undefined];\n    };\n    const loopThruSpecificHandlers = () => {\n        for (let i = 0; i < specificHandlers_js_1.specificHandlers.length; i += 1) {\n            const key = specificHandlers_js_1.specificHandlers[i];\n            const handler = typeHandlers_js_1.default[key];\n            const specificResult = handler.validate(view, toAscii);\n            if (specificResult) {\n                return key;\n            }\n        }\n        return undefined;\n    };\n    const [found, handleType] = detectionByFirstByte();\n    if (found) {\n        return handleType;\n    }\n    else {\n        return loopThruSpecificHandlers();\n    }\n}\nexports.default = detectImageType;\n;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typeHandlers_js_1 = __importDefault(require(\"./types/typeHandlers.js\"));\nconst keys = Object.keys(typeHandlers_js_1.default);\n// This map helps avoid validating for every single image type\nconst firstBytes = {\n    0x38: 'psd',\n    0x42: 'bmp',\n    0x44: 'dds',\n    0x47: 'gif',\n    // 0x49: 'tiff',\n    // 0x4d: 'tiff',\n    0x52: 'webp',\n    0x69: 'icns',\n    0x89: 'png',\n    0xff: 'jpg',\n};\n/** @internal */\nexports.default = firstBytes;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lookup_js_1 = __importDefault(require(\"./lookup.js\"));\nconst detectImageType_js_1 = __importDefault(require(\"./detectImageType.js\"));\n/**\n * get image size and type from a DataView of buffer\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {\n *  {\n *    width: number,\n *    height: number,\n *    images: []\n *    type: string\n *  }\n * } image size\n */\n/** @internal */\nfunction imageSize(view, toAscii) {\n    if (typeof toAscii !== 'function') {\n        throw new Error('toAscii is not a callback function');\n    }\n    // detect the file type.. don't rely on the extension\n    const type = detectImageType_js_1.default(view, toAscii);\n    return lookup_js_1.default(type, view, toAscii);\n}\nexports.default = imageSize;\n;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTiffBigEndian = exports.viewTiffImage = exports.detectImageType = exports.imageSize = void 0;\nvar imageSize_js_1 = require(\"./imageSize.js\");\nObject.defineProperty(exports, \"imageSize\", { enumerable: true, get: function () { return __importDefault(imageSize_js_1).default; } });\nvar detectImageType_js_1 = require(\"./detectImageType.js\");\nObject.defineProperty(exports, \"detectImageType\", { enumerable: true, get: function () { return __importDefault(detectImageType_js_1).default; } });\nvar viewTiffImage_js_1 = require(\"./viewTiffImage.js\");\nObject.defineProperty(exports, \"viewTiffImage\", { enumerable: true, get: function () { return __importDefault(viewTiffImage_js_1).default; } });\nvar isTiffBigEndian_js_1 = require(\"./isTiffBigEndian.js\");\nObject.defineProperty(exports, \"isTiffBigEndian\", { enumerable: true, get: function () { return __importDefault(isTiffBigEndian_js_1).default; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Test if the TIFF is Big Endian or Little Endian\nfunction isTiffBigEndian(view, toAscii, offset) {\n    const signature = toAscii(view, offset, 2);\n    if ('II' === signature) {\n        return false;\n    }\n    else if ('MM' === signature) {\n        return true;\n    }\n    else {\n        throw new TypeError(`Tiff endian error - ${signature}`);\n    }\n}\nexports.default = isTiffBigEndian;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typeHandlers_js_1 = __importDefault(require(\"./types/typeHandlers.js\"));\n/**\n * Return size information based on a buffer\n *\n * @param {imageType | undefined} type detector return by detectType()\n * @param {DataView} view\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {ISizeCalculationResult}\n */\n/** @internal */\nfunction lookup(type, view, toAscii) {\n    if (typeof type !== 'undefined') {\n        // find an appropriate handler for this file type\n        if (type in typeHandlers_js_1.default) {\n            const size = typeHandlers_js_1.default[type].calculate(view, toAscii);\n            if (size !== undefined) {\n                size.type = type;\n                return size;\n            }\n        }\n    }\n    // throw up, if we don't understand the image type\n    throw new TypeError('unsupported image type: ' + type);\n}\nexports.default = lookup;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readUInt32LE = exports.readUInt32BE = exports.readUInt32 = exports.readUInt16LE = exports.readUInt16BE = exports.readUInt16 = exports.readUInt24LE = exports.readInt32LE = exports.readInt16LE = void 0;\n/** @internal */\nfunction readInt16LE(view, offset) {\n    return view.getInt16(offset, true);\n}\nexports.readInt16LE = readInt16LE;\n/** @internal */\nfunction readInt32LE(view, offset) {\n    return view.getInt32(offset, true);\n}\nexports.readInt32LE = readInt32LE;\n/** @internal */\nfunction readUInt24LE(view, offset) {\n    return view.getUint32(offset, true) & 0xffffff;\n}\nexports.readUInt24LE = readUInt24LE;\n/** @internal */\nfunction readUInt16(view, offset, isBigEndian) {\n    return view.getUint16(offset, !isBigEndian);\n}\nexports.readUInt16 = readUInt16;\n/** @internal */\nfunction readUInt16BE(view, offset) {\n    return view.getUint16(offset, false);\n}\nexports.readUInt16BE = readUInt16BE;\n/** @internal */\nfunction readUInt16LE(view, offset) {\n    return view.getUint16(offset, true);\n}\nexports.readUInt16LE = readUInt16LE;\n/** @internal */\nfunction readUInt32(view, offset, isBigEndian) {\n    return view.getUint32(offset, !isBigEndian);\n}\nexports.readUInt32 = readUInt32;\n/** @internal */\nfunction readUInt32BE(view, offset) {\n    return view.getUint32(offset, false);\n}\nexports.readUInt32BE = readUInt32BE;\n/** @internal */\nfunction readUInt32LE(view, offset) {\n    return view.getUint32(offset, true);\n}\nexports.readUInt32LE = readUInt32LE;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internal */\nfunction toHexadecimal(view, begin, end) {\n    let output = '';\n    for (let i = begin; i < end; i += 1) {\n        const value = view.getUint8(i);\n        output += value.toString(16).padStart(2, '0');\n    }\n    return output;\n}\nexports.default = toHexadecimal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BMP = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\n/** @internal */\nexports.BMP = {\n    validate(buffer, toAscii) {\n        return 'BM' === toAscii(buffer, 0, 2);\n    },\n    calculate(buffer) {\n        return {\n            height: Math.abs(readUInt_js_1.readInt32LE(buffer, 22)),\n            width: readUInt_js_1.readUInt32LE(buffer, 18),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CUR = void 0;\nconst ico_js_1 = require(\"./ico.js\");\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst TYPE_CURSOR = 2;\n/** @internal */\nexports.CUR = {\n    validate(buffer) {\n        if (readUInt_js_1.readUInt16LE(buffer, 0) !== 0) {\n            return false;\n        }\n        return readUInt_js_1.readUInt16LE(buffer, 2) === TYPE_CURSOR;\n    },\n    calculate(buffer, toAscii) {\n        return ico_js_1.ICO.calculate(buffer, toAscii);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDS = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\n/** @internal */\nexports.DDS = {\n    validate(buffer) {\n        return readUInt_js_1.readUInt32LE(buffer, 0) === 0x20534444;\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_js_1.readUInt32LE(buffer, 12),\n            width: readUInt_js_1.readUInt32LE(buffer, 16),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GIF = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst gifRegexp = /^GIF8[79]a/;\n/** @internal */\nexports.GIF = {\n    validate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 6);\n        return gifRegexp.test(signature);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_js_1.readUInt16LE(buffer, 8),\n            width: readUInt_js_1.readUInt16LE(buffer, 6),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICNS = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n */\nconst SIZE_HEADER = 4 + 4; // 8\nconst FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n */\nconst ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\nconst ICON_TYPE_SIZE = {\n    ICON: 32,\n    'ICN#': 32,\n    // m => 16 x 16\n    'icm#': 16,\n    icm4: 16,\n    icm8: 16,\n    // s => 16 x 16\n    'ics#': 16,\n    ics4: 16,\n    ics8: 16,\n    is32: 16,\n    s8mk: 16,\n    icp4: 16,\n    // l => 32 x 32\n    icl4: 32,\n    icl8: 32,\n    il32: 32,\n    l8mk: 32,\n    icp5: 32,\n    ic11: 32,\n    // h => 48 x 48\n    ich4: 48,\n    ich8: 48,\n    ih32: 48,\n    h8mk: 48,\n    // . => 64 x 64\n    icp6: 64,\n    ic12: 32,\n    // t => 128 x 128\n    it32: 128,\n    t8mk: 128,\n    ic07: 128,\n    // . => 256 x 256\n    ic08: 256,\n    ic13: 256,\n    // . => 512 x 512\n    ic09: 512,\n    ic14: 512,\n    // . => 1024 x 1024\n    ic10: 1024,\n};\nfunction readImageHeader(buffer, imageOffset, toAscii) {\n    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n    return [\n        toAscii(buffer, imageOffset, imageLengthOffset),\n        readUInt_js_1.readUInt32BE(buffer, imageLengthOffset),\n    ];\n}\nfunction getImageSize(type) {\n    const size = ICON_TYPE_SIZE[type];\n    return { width: size, height: size, type };\n}\n/** @internal */\nexports.ICNS = {\n    validate(buffer, toAscii) {\n        return 'icns' === toAscii(buffer, 0, 4);\n    },\n    calculate(buffer, toAscii) {\n        const bufferLength = buffer.byteLength;\n        const fileLength = readUInt_js_1.readUInt32BE(buffer, FILE_LENGTH_OFFSET);\n        let imageOffset = SIZE_HEADER;\n        let imageHeader = readImageHeader(buffer, imageOffset, toAscii);\n        let imageSize = getImageSize(imageHeader[0]);\n        imageOffset += imageHeader[1];\n        if (imageOffset === fileLength) {\n            return imageSize;\n        }\n        const result = {\n            height: imageSize.height,\n            images: [imageSize],\n            width: imageSize.width,\n        };\n        while (imageOffset < fileLength && imageOffset < bufferLength) {\n            imageHeader = readImageHeader(buffer, imageOffset, toAscii);\n            imageSize = getImageSize(imageHeader[0]);\n            imageOffset += imageHeader[1];\n            result.images.push(imageSize);\n        }\n        return result;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICO = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst TYPE_ICON = 1;\n/**\n * ICON Header\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 2    | Reserved. Must always be 0.  |\n * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |\n * | 4      | 2    | Number of images in the file. |\n *\n */\nconst SIZE_HEADER = 2 + 2 + 2; // 6\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |\n * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |\n * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |\n * | 3      | 1    | Reserved. Should be 0. |\n * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |\n * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |\n * | 6      | 2    | ICO format: Bits per pixel. |\n * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |\n * | 8      | 4    | The size of the image's data in bytes |\n * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |\n *\n */\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16\nfunction getSizeFromOffset(buffer, offset) {\n    const value = buffer.getUint8(offset);\n    return value === 0 ? 256 : value;\n}\nfunction getImageSize(buffer, imageIndex) {\n    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;\n    return {\n        height: getSizeFromOffset(buffer, offset + 1),\n        width: getSizeFromOffset(buffer, offset),\n    };\n}\n/** @internal */\nexports.ICO = {\n    validate(buffer) {\n        if (readUInt_js_1.readUInt16LE(buffer, 0) !== 0) {\n            return false;\n        }\n        return readUInt_js_1.readUInt16LE(buffer, 2) === TYPE_ICON;\n    },\n    calculate(buffer, toAscii) {\n        const nbImages = readUInt_js_1.readUInt16LE(buffer, 4);\n        const imageSize = getImageSize(buffer, 0);\n        if (nbImages === 1) {\n            return imageSize;\n        }\n        const imgs = [imageSize];\n        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n            imgs.push(getImageSize(buffer, imageIndex));\n        }\n        const result = {\n            height: imageSize.height,\n            images: imgs,\n            width: imageSize.width,\n        };\n        return result;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst EXIF_MARKER_HI_UINT32_BE = 1165519206;\nconst EXIF_MARKER_LO_UINT16_BE = 0;\nconst compareEXIFIdentifier = (view, offset) => {\n    const identifierHi = readUInt_js_1.readUInt32BE(view, offset);\n    const identiferLo = readUInt_js_1.readUInt16BE(view, offset + 4);\n    // console.log('=identifier', identifierHi, identiferLo)\n    return (identifierHi === EXIF_MARKER_HI_UINT32_BE &&\n        identiferLo === EXIF_MARKER_LO_UINT16_BE);\n};\n/** @internal */\nfunction isEXIFAppMarker(view, shortMarker, offset) {\n    // console.log('@identifier', offset);\n    if (shortMarker == 0xffe1) {\n        const flag = compareEXIFIdentifier(view, offset);\n        // const identifer = toAscii(view, offset, offset + 6);\n        // console.log('=identifier', identifer, flag);\n        return flag;\n    }\n    else {\n        return false;\n    }\n}\nexports.default = isEXIFAppMarker;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.J2C = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst toHexadecimal_js_1 = __importDefault(require(\"../toHexadecimal.js\"));\n/** @internal */\nexports.J2C = {\n    validate(buffer) {\n        // TODO: this doesn't seem right. SIZ marker doesnt have to be right after the SOC\n        return toHexadecimal_js_1.default(buffer, 0, 4) === 'ff4fff51';\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_js_1.readUInt32BE(buffer, 12),\n            width: readUInt_js_1.readUInt32BE(buffer, 8),\n        };\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JP2 = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst toHexadecimal_js_1 = __importDefault(require(\"../toHexadecimal.js\"));\nconst BoxTypes = {\n    ftyp: '66747970',\n    ihdr: '69686472',\n    jp2h: '6a703268',\n    jp__: '6a502020',\n    rreq: '72726571',\n    xml_: '786d6c20',\n};\nconst calculateRREQLength = (box, begin) => {\n    const unit = box.getUint8(begin);\n    let offset = begin + 1 + 2 * unit;\n    const numStdFlags = readUInt_js_1.readUInt16BE(box, offset);\n    const flagsLength = numStdFlags * (2 + unit);\n    offset = offset + 2 + flagsLength;\n    const numVendorFeatures = readUInt_js_1.readUInt16BE(box, offset);\n    const featuresLength = numVendorFeatures * (16 + unit);\n    return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box, offset) => {\n    return {\n        height: readUInt_js_1.readUInt32BE(box, offset + 4),\n        width: readUInt_js_1.readUInt32BE(box, offset + 8),\n    };\n};\n/** @internal */\nexports.JP2 = {\n    validate(buffer) {\n        const signature = toHexadecimal_js_1.default(buffer, 4, 8);\n        const signatureLength = readUInt_js_1.readUInt32BE(buffer, 0);\n        if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n            return false;\n        }\n        const ftypeBoxStart = signatureLength + 4;\n        // const ftypBoxLength = readUInt32BE(buffer, signatureLength)\n        // const ftypBox = buffer.buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength)\n        return (toHexadecimal_js_1.default(buffer, ftypeBoxStart, ftypeBoxStart + 4) === BoxTypes.ftyp);\n    },\n    calculate(buffer, toAscii) {\n        const signatureLength = readUInt_js_1.readUInt32BE(buffer, 0);\n        const ftypBoxLength = readUInt_js_1.readUInt16BE(buffer, signatureLength + 2);\n        let offset = signatureLength + 4 + ftypBoxLength;\n        const nextBoxType = toHexadecimal_js_1.default(buffer, offset, offset + 4);\n        switch (nextBoxType) {\n            case BoxTypes.rreq:\n                // WHAT ARE THESE 4 BYTES?????\n                // eslint-disable-next-line no-case-declarations\n                const MAGIC = 4;\n                offset = offset + 4 + MAGIC + calculateRREQLength(buffer, offset + 4);\n                return parseIHDR(buffer, offset + 8);\n            case BoxTypes.jp2h:\n                return parseIHDR(buffer, offset + 8);\n            default:\n                throw new TypeError('Unsupported header found: ' + toAscii(buffer, offset, offset + 4));\n        }\n    },\n};\n","\"use strict\";\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JPG = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst toHexadecimal_js_1 = __importDefault(require(\"../toHexadecimal.js\"));\nconst validateJPG_js_1 = __importDefault(require(\"./validateJPG.js\"));\nconst readJpgBlockLength_js_1 = __importDefault(require(\"./readJpgBlockLength.js\"));\nconst isEXIFAppMarker_js_1 = __importDefault(require(\"./isEXIFAppMarker.js\"));\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\n// function isEXIF(buffer: DataView, offset: number): boolean {\n//   return toHexadecimal(buffer, offset + 2, offset + 6) === EXIF_MARKER;\n// }\nfunction extractSize(buffer, index) {\n    return {\n        height: readUInt_js_1.readUInt16BE(buffer, index),\n        width: readUInt_js_1.readUInt16BE(buffer, index + 2),\n    };\n}\nfunction extractOrientation(exifBlock, begin, isBigEndian) {\n    // TODO: assert that this contains 0x002A\n    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n    const idfOffset = 8;\n    // IDF osset works from right after the header bytes\n    // (so the offset includes the tiff byte align)\n    const offset = begin + EXIF_HEADER_BYTES + idfOffset;\n    const idfDirectoryEntries = readUInt_js_1.readUInt16(exifBlock, offset, isBigEndian);\n    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n        const start = offset +\n            NUM_DIRECTORY_ENTRIES_BYTES +\n            directoryEntryNumber * IDF_ENTRY_BYTES;\n        const end = start + IDF_ENTRY_BYTES;\n        // Skip on corrupt EXIF blocks\n        if (start > exifBlock.byteLength) {\n            return;\n        }\n        // const block = exifBlock.slice(start, end)\n        const blockStart = start;\n        const tagNumber = readUInt_js_1.readUInt16(exifBlock, blockStart, isBigEndian);\n        // 0x0112 (decimal: 274) is the `orientation` tag ID\n        if (tagNumber === 274) {\n            const dataFormat = readUInt_js_1.readUInt16(exifBlock, blockStart + 2, isBigEndian);\n            if (dataFormat !== 3) {\n                return;\n            }\n            // unsinged int has 2 bytes per component\n            // if there would more than 4 bytes in total it's a pointer\n            const numberOfComponents = readUInt_js_1.readUInt32(exifBlock, blockStart + 4, isBigEndian);\n            if (numberOfComponents !== 1) {\n                return;\n            }\n            return readUInt_js_1.readUInt16(exifBlock, blockStart + 8, isBigEndian);\n        }\n    }\n}\nfunction validateExifBlock(buffer, index) {\n    // Skip APP1 Data Size\n    // const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index)\n    const start = index;\n    // Consider byte alignment\n    // const byteAlign = toHexadecimal(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES)\n    const byteAlign = toHexadecimal_js_1.default(buffer, index + EXIF_HEADER_BYTES, index + EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n    // Ignore Empty EXIF. Validate byte alignment\n    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n    if (isBigEndian || isLittleEndian) {\n        return extractOrientation(buffer, index, isBigEndian);\n    }\n}\nfunction validateBuffer(buffer, index) {\n    // index should be within buffer limits\n    if (index > buffer.byteLength) {\n        throw new TypeError(`Corrupt JPG index (${index}), exceeded buffer limits (${buffer.byteLength})`);\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (buffer.getUint8(index) !== 0xff) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\nconst readMarker = (view, index) => {\n    return readUInt_js_1.readUInt16BE(view, index);\n};\n/** @internal */\nexports.JPG = {\n    validate(buffer) {\n        const markerShort = validateJPG_js_1.default(buffer); // SOI\n        return markerShort === 'ffd8';\n    },\n    calculate(buffer, toAscii) {\n        // Skip 2 bytes, first is SOI\n        let offset = 2;\n        let orientation;\n        let next;\n        while (offset < buffer.byteLength) {\n            // or EOI 0xffD9\n            // console.log('@shortMarker', offset)\n            const shortMarker = readMarker(buffer, offset);\n            // console.log('=shortMarker ', shortMarker.toString(16));\n            let markerOffset = offset + 2;\n            // console.log('@blockLength', markerOffset)\n            const blockLength = readJpgBlockLength_js_1.default(buffer, markerOffset);\n            // console.log('=blockLength', blockLength)\n            const headerOffset = markerOffset + 2;\n            if (isEXIFAppMarker_js_1.default(buffer, shortMarker, headerOffset)) {\n                // console.log('EXIF HERE')\n                const EXIF_IDENTIFIER_ID_LEN = 6;\n                orientation = validateExifBlock(buffer, headerOffset + EXIF_IDENTIFIER_ID_LEN);\n                // console.log('orientation', orientation);\n            }\n            // ensure correct format\n            validateBuffer(buffer, offset);\n            // 0xFFC0 is baseline standard(SOF)\n            // 0xFFC1 is baseline optimized(SOF)\n            // 0xFFC2 is progressive(SOF2)\n            // next = buffer.getUint8(i + 1);\n            if (shortMarker === 0xffc0 ||\n                shortMarker === 0xffc1 ||\n                shortMarker === 0xffc2) {\n                // https://www.ccoderun.ca/programming/2017-01-31_jpeg/\n                const size = extractSize(buffer, markerOffset + 3);\n                // TODO: is orientation=0 a valid answer here?\n                if (!orientation) {\n                    return size;\n                }\n                return {\n                    height: size.height,\n                    orientation,\n                    width: size.width,\n                };\n            }\n            // move to the next block\n            offset = markerOffset + blockLength;\n            // buffer = buffer.slice(i + 2)\n        }\n        throw new TypeError('Invalid JPG, no size found');\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KTX = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst SIGNATURE = 'KTX 11';\n/** @internal */\nexports.KTX = {\n    validate(buffer, toAscii) {\n        return SIGNATURE === toAscii(buffer, 1, 7);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_js_1.readUInt32LE(buffer, 40),\n            width: readUInt_js_1.readUInt32LE(buffer, 36),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNG = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst pngSignature = 'PNG\\r\\n\\x1a\\n';\nconst pngImageHeaderChunkName = 'IHDR';\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nconst pngFriedChunkName = 'CgBI';\n/** @internal */\nexports.PNG = {\n    validate(buffer, toAscii) {\n        if (pngSignature === toAscii(buffer, 1, 8)) {\n            let chunkName = toAscii(buffer, 12, 16);\n            if (chunkName === pngFriedChunkName) {\n                chunkName = toAscii(buffer, 28, 32);\n            }\n            if (chunkName !== pngImageHeaderChunkName) {\n                throw new TypeError('Invalid PNG');\n            }\n            return true;\n        }\n        return false;\n    },\n    calculate(buffer, toAscii) {\n        if (toAscii(buffer, 12, 16) === pngFriedChunkName) {\n            return {\n                height: readUInt_js_1.readUInt32BE(buffer, 36),\n                width: readUInt_js_1.readUInt32BE(buffer, 32),\n            };\n        }\n        return {\n            height: readUInt_js_1.readUInt32BE(buffer, 20),\n            width: readUInt_js_1.readUInt32BE(buffer, 16),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNM = void 0;\nconst PNMTypes = {\n    P1: 'pbm/ascii',\n    P2: 'pgm/ascii',\n    P3: 'ppm/ascii',\n    P4: 'pbm',\n    P5: 'pgm',\n    P6: 'ppm',\n    P7: 'pam',\n    PF: 'pfm',\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n    default: (lines) => {\n        let dimensions = [];\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line[0] === '#') {\n                continue;\n            }\n            dimensions = line.split(' ');\n            break;\n        }\n        if (dimensions.length === 2) {\n            return {\n                height: parseInt(dimensions[1], 10),\n                width: parseInt(dimensions[0], 10),\n            };\n        }\n        else {\n            throw new TypeError('Invalid PNM');\n        }\n    },\n    pam: (lines) => {\n        const size = {};\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line.length > 16 || line.charCodeAt(0) > 128) {\n                continue;\n            }\n            const [key, value] = line.split(' ');\n            if (key && value) {\n                size[key.toLowerCase()] = parseInt(value, 10);\n            }\n            if (size.height && size.width) {\n                break;\n            }\n        }\n        if (size.height && size.width) {\n            return {\n                height: size.height,\n                width: size.width,\n            };\n        }\n        else {\n            throw new TypeError('Invalid PAM');\n        }\n    },\n};\n/** @internal */\nexports.PNM = {\n    validate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 2);\n        return Signatures.includes(signature);\n    },\n    calculate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 2);\n        const type = PNMTypes[signature];\n        // TODO: this probably generates garbage. move to a stream based parser\n        // const lines = buffer.toString('ascii', 3).split(/[\\r\\n]+/)\n        const lines = toAscii(buffer, 3, buffer.byteLength).split(/[\\r\\n]+/);\n        const handler = handlers[type] || handlers.default;\n        return handler(lines);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PSD = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\n/** @internal */\nexports.PSD = {\n    validate(buffer, toAscii) {\n        return '8BPS' === toAscii(buffer, 0, 4);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_js_1.readUInt32BE(buffer, 14),\n            width: readUInt_js_1.readUInt32BE(buffer, 18),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst readUInt_js_1 = require(\"../readUInt.js\");\n/** @internal */\nfunction readJpgBlockLength(view, offset) {\n    // read length of the next block\n    return readUInt_js_1.readUInt16BE(view, offset);\n}\nexports.default = readJpgBlockLength;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.specificHandlers = void 0;\n// [\"cur\", \"ico\", \"j2c\", \"jp2\", \"ktx\", \"pnm\", \"svg\"]\n// every image handler not covered by the first byte lookup\n/** @internal */\nexports.specificHandlers = [\n    'cur',\n    'ico',\n    'j2c',\n    'jp2',\n    'ktx',\n    'pnm',\n    'svg',\n    'tiff',\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SVG = void 0;\nconst svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n    height: /\\sheight=(['\"])([^%]+?)\\1/,\n    root: svgReg,\n    viewbox: /\\sviewBox=(['\"])(.+?)\\1/i,\n    width: /\\swidth=(['\"])([^%]+?)\\1/,\n};\nconst INCH_CM = 2.54;\nconst units = {\n    in: 96,\n    cm: 96 / INCH_CM,\n    em: 16,\n    ex: 8,\n    m: (96 / INCH_CM) * 100,\n    mm: 96 / INCH_CM / 10,\n    pc: 96 / 72 / 12,\n    pt: 96 / 72,\n    px: 1,\n};\nconst unitsReg = new RegExp(`^([0-9.]+(?:e\\\\d+)?)(${Object.keys(units).join('|')})?$`);\nfunction parseLength(len) {\n    const m = unitsReg.exec(len);\n    if (!m) {\n        return undefined;\n    }\n    return Math.round(Number(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n    const bounds = viewbox.split(' ');\n    return {\n        height: parseLength(bounds[3]),\n        width: parseLength(bounds[2]),\n    };\n}\nfunction parseAttributes(root) {\n    const width = root.match(extractorRegExps.width);\n    const height = root.match(extractorRegExps.height);\n    const viewbox = root.match(extractorRegExps.viewbox);\n    return {\n        height: height && parseLength(height[2]),\n        viewbox: viewbox && parseViewbox(viewbox[2]),\n        width: width && parseLength(width[2]),\n    };\n}\nfunction calculateByDimensions(attrs) {\n    return {\n        height: attrs.height,\n        width: attrs.width,\n    };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n    const ratio = viewbox.width / viewbox.height;\n    if (attrs.width) {\n        return {\n            height: Math.floor(attrs.width / ratio),\n            width: attrs.width,\n        };\n    }\n    if (attrs.height) {\n        return {\n            height: attrs.height,\n            width: Math.floor(attrs.height * ratio),\n        };\n    }\n    return {\n        height: viewbox.height,\n        width: viewbox.width,\n    };\n}\nfunction toUtf8String(view) {\n    const decoder = new TextDecoder('utf8');\n    return decoder.decode(view);\n}\n/** @internal */\nexports.SVG = {\n    validate(buffer) {\n        const str = toUtf8String(buffer);\n        return svgReg.test(str);\n    },\n    calculate(buffer) {\n        const root = toUtf8String(buffer).match(extractorRegExps.root);\n        if (root) {\n            const attrs = parseAttributes(root[0]);\n            if (attrs.width && attrs.height) {\n                return calculateByDimensions(attrs);\n            }\n            if (attrs.viewbox) {\n                return calculateByViewbox(attrs, attrs.viewbox);\n            }\n        }\n        throw new TypeError('Invalid SVG');\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TIFF = void 0;\nconst toHexadecimal_js_1 = __importDefault(require(\"../toHexadecimal.js\"));\nconst isTiffBigEndian_js_1 = __importDefault(require(\"../isTiffBigEndian.js\"));\nconst tiffHelpers_js_1 = require(\"./tiffHelpers.js\");\nconst signatures = [\n    // '492049', // currently not supported\n    '49492a00',\n    '4d4d002a', // Big Endian\n    // '4d4d002a', // BigTIFF > 4GB. currently not supported\n];\n/** @internal */\nexports.TIFF = {\n    validate(view, toAscii) {\n        const fileSignature = toHexadecimal_js_1.default(view, 0, 4);\n        // console.log('file sig', fileSignature);\n        return signatures.includes(fileSignature);\n    },\n    calculate(view, toAscii) {\n        // Determine BE/LE\n        const initialLocation = tiffHelpers_js_1.getIdfOffsetLocation();\n        const isBigEndian = isTiffBigEndian_js_1.default(view, toAscii, initialLocation);\n        // read the IFD\n        const ifdOffset = tiffHelpers_js_1.getIdfOffset(view, isBigEndian);\n        // extract the tags from the IFD\n        const tags = {};\n        let nextOffset = ifdOffset;\n        do {\n            const noOfEntries = tiffHelpers_js_1.getNoOfIdfEntries(view, nextOffset, isBigEndian);\n            const start = tiffHelpers_js_1.beginIndexForIdf(nextOffset);\n            const end = tiffHelpers_js_1.endIndexForIdf(nextOffset, noOfEntries);\n            const stride = tiffHelpers_js_1.getStrideForIdf();\n            for (let i = start; i < end; i += stride) {\n                tiffHelpers_js_1.extractIdfEntry(tags, view, i, isBigEndian);\n            }\n            nextOffset = tiffHelpers_js_1.getIdfOffset(view, isBigEndian, end);\n        } while (nextOffset !== 0);\n        return tiffHelpers_js_1.intoResult(tags);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intoResult = exports.extractIdfEntry = exports.endIndexForIdf = exports.getStrideForIdf = exports.beginIndexForIdf = exports.TIFF_IDF_ENTRY_STRIDE = exports.TIFF_IDF_OFFSET_SIZE = exports.TIFF_IDF_COUNT_STRIDE = exports.getNoOfIdfEntries = exports.getIdfOffset = exports.getIdfOffsetLocation = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst TIFF_FILE_DEFAULT = 4;\n/** @internal */\nfunction getIdfOffsetLocation() {\n    return TIFF_FILE_DEFAULT;\n}\nexports.getIdfOffsetLocation = getIdfOffsetLocation;\n/** @internal */\nfunction getIdfOffset(view, isBigEndian, offset = TIFF_FILE_DEFAULT) {\n    return readUInt_js_1.readUInt32(view, offset, isBigEndian);\n}\nexports.getIdfOffset = getIdfOffset;\nconst SHORT_TYPE = 3;\nconst LONG_TYPE = 4;\n/** @internal */\nfunction getNoOfIdfEntries(view, offset, isBigEndian) {\n    return readUInt_js_1.readUInt16(view, offset, isBigEndian);\n}\nexports.getNoOfIdfEntries = getNoOfIdfEntries;\n/** @internal */\nexports.TIFF_IDF_COUNT_STRIDE = 2;\n/** @internal */\nexports.TIFF_IDF_OFFSET_SIZE = 4;\n/** @internal */\nexports.TIFF_IDF_ENTRY_STRIDE = 12;\n/** @internal */\nfunction beginIndexForIdf(offset) {\n    return offset + 2;\n}\nexports.beginIndexForIdf = beginIndexForIdf;\n/** @internal */\nfunction getStrideForIdf() {\n    return exports.TIFF_IDF_ENTRY_STRIDE;\n}\nexports.getStrideForIdf = getStrideForIdf;\n/** @internal */\nfunction endIndexForIdf(offset, noOfEntries) {\n    return offset + 2 + noOfEntries * exports.TIFF_IDF_ENTRY_STRIDE;\n}\nexports.endIndexForIdf = endIndexForIdf;\n// Extract IFD tags from TIFF metadata\n/** @internal */\nfunction extractIdfEntry(tags, view, directoryOffset, isBigEndian) {\n    const code = readUInt_js_1.readUInt16(view, directoryOffset + 0, isBigEndian);\n    const type = readUInt_js_1.readUInt16(view, directoryOffset + 2, isBigEndian);\n    const count = readUInt_js_1.readUInt32(view, directoryOffset + 4, isBigEndian);\n    // 256 is width, 257 is height\n    // if (code === 256 || code === 257) {\n    // singular values not arrays or string\n    if (count === 1) {\n        const valueFieldOffset = directoryOffset + 8;\n        switch (type) {\n            case SHORT_TYPE:\n                tags[code] = readUInt_js_1.readUInt16(view, valueFieldOffset, isBigEndian);\n                break;\n            case LONG_TYPE:\n                tags[code] = readUInt_js_1.readUInt32(view, valueFieldOffset, isBigEndian);\n                break;\n        }\n    }\n}\nexports.extractIdfEntry = extractIdfEntry;\nconst WIDTH_TAG = 256;\nconst HEIGHT_TAG = 257;\n/** @internal */\nfunction intoResult(tags) {\n    const width = tags[WIDTH_TAG];\n    const height = tags[HEIGHT_TAG];\n    if (!width || !height) {\n        throw new TypeError('Invalid Tiff. Missing tags');\n    }\n    return { height, width, type: 'tiff' };\n}\nexports.intoResult = intoResult;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// load all available handlers explicitely for browserify support\nconst bmp_js_1 = require(\"./bmp.js\");\nconst cur_js_1 = require(\"./cur.js\");\nconst dds_js_1 = require(\"./dds.js\");\nconst gif_js_1 = require(\"./gif.js\");\nconst icns_js_1 = require(\"./icns.js\");\nconst ico_js_1 = require(\"./ico.js\");\nconst j2c_js_1 = require(\"./j2c.js\");\nconst jp2_js_1 = require(\"./jp2.js\");\nconst jpg_js_1 = require(\"./jpg.js\");\nconst ktx_js_1 = require(\"./ktx.js\");\nconst png_js_1 = require(\"./png.js\");\nconst pnm_js_1 = require(\"./pnm.js\");\nconst psd_js_1 = require(\"./psd.js\");\nconst svg_js_1 = require(\"./svg.js\");\nconst tiff_js_1 = require(\"./tiff.js\");\nconst webp_js_1 = require(\"./webp.js\");\nconst typeHandlers = {\n    bmp: bmp_js_1.BMP,\n    cur: cur_js_1.CUR,\n    dds: dds_js_1.DDS,\n    gif: gif_js_1.GIF,\n    icns: icns_js_1.ICNS,\n    ico: ico_js_1.ICO,\n    j2c: j2c_js_1.J2C,\n    jp2: jp2_js_1.JP2,\n    jpg: jpg_js_1.JPG,\n    ktx: ktx_js_1.KTX,\n    png: png_js_1.PNG,\n    pnm: pnm_js_1.PNM,\n    psd: psd_js_1.PSD,\n    svg: svg_js_1.SVG,\n    tiff: tiff_js_1.TIFF,\n    webp: webp_js_1.WEBP,\n};\n/** @internal */\nexports.default = typeHandlers;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst toHexadecimal_js_1 = __importDefault(require(\"../toHexadecimal.js\"));\n/** @internal */\nfunction validateJPG(view) {\n    const SOIMarker = toHexadecimal_js_1.default(view, 0, 2);\n    return SOIMarker;\n}\nexports.default = validateJPG;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WEBP = void 0;\nconst readUInt_js_1 = require(\"../readUInt.js\");\nconst toHexadecimal_js_1 = __importDefault(require(\"../toHexadecimal.js\"));\nfunction calculateExtended(buffer, offset) {\n    return {\n        height: 1 + readUInt_js_1.readUInt24LE(buffer, offset + 7),\n        width: 1 + readUInt_js_1.readUInt24LE(buffer, offset + 4),\n    };\n}\nfunction calculateLossless(buffer, offset) {\n    const a = buffer.getUint8(offset + 4);\n    const b = buffer.getUint8(offset + 3);\n    const c = buffer.getUint8(offset + 2);\n    const d = buffer.getUint8(offset + 2);\n    const e = buffer.getUint8(offset + 1);\n    return {\n        height: 1 + (((a & 0xf) << 10) | (b << 2) | ((c & 0xc0) >> 6)),\n        width: 1 + (((d & 0x3f) << 8) | e),\n    };\n}\nfunction calculateLossy(buffer, offset) {\n    // `& 0x3fff` returns the last 14 bits\n    // TO-DO: include webp scaling in the calculations\n    return {\n        height: readUInt_js_1.readInt16LE(buffer, offset + 8) & 0x3fff,\n        width: readUInt_js_1.readInt16LE(buffer, offset + 6) & 0x3fff,\n    };\n}\n/** @internal */\nexports.WEBP = {\n    validate(buffer, toAscii) {\n        const riffHeader = 'RIFF' === toAscii(buffer, 0, 4);\n        const webpHeader = 'WEBP' === toAscii(buffer, 8, 12);\n        const vp8Header = 'VP8' === toAscii(buffer, 12, 15);\n        return riffHeader && webpHeader && vp8Header;\n    },\n    calculate(buffer, toAscii) {\n        const chunkHeader = toAscii(buffer, 12, 16);\n        // const sample = buffer.slice(20, 30)\n        const sampleStart = 20;\n        // Extended webp stream signature\n        if (chunkHeader === 'VP8X') {\n            const extendedHeader = buffer.getUint8(sampleStart);\n            const validStart = (extendedHeader & 0xc0) === 0;\n            const validEnd = (extendedHeader & 0x01) === 0;\n            if (validStart && validEnd) {\n                return calculateExtended(buffer, sampleStart);\n            }\n            else {\n                // TODO: breaking change\n                throw new TypeError('Invalid WebP');\n            }\n        }\n        // Lossless webp stream signature\n        if (chunkHeader === 'VP8 ' && buffer.getUint8(sampleStart) !== 0x2f) {\n            return calculateLossy(buffer, sampleStart);\n        }\n        // Lossy webp stream signature\n        const signature = toHexadecimal_js_1.default(buffer, sampleStart + 3, sampleStart + 6);\n        if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n            return calculateLossless(buffer, sampleStart);\n        }\n        throw new TypeError('Invalid WebP');\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tiffHelpers_js_1 = require(\"./types/tiffHelpers.js\");\nconst moveToIdfCount = (pos, adjust) => {\n    return adjust(pos, tiffHelpers_js_1.TIFF_IDF_COUNT_STRIDE); // 2 bytes\n};\nconst getMinimumBufferSizeRequired = (location) => {\n    return tiffHelpers_js_1.TIFF_IDF_COUNT_STRIDE + location + tiffHelpers_js_1.TIFF_IDF_OFFSET_SIZE;\n};\nconst readIdfCount = (view, isBigEndian) => {\n    const count = tiffHelpers_js_1.getNoOfIdfEntries(view, 0, isBigEndian);\n    return count;\n};\nfunction viewTiffImage(isBigEndian, adjust) {\n    const tags = {};\n    // BEGINNING\n    const START_OF_FILE = 0;\n    const TIFF_HEADER_SIZE = 8;\n    // user-specified / ADJUST\n    let view = adjust(START_OF_FILE, TIFF_HEADER_SIZE);\n    let initLocation = tiffHelpers_js_1.getIdfOffsetLocation(); // 4\n    let offset = tiffHelpers_js_1.getIdfOffset(view, isBigEndian, initLocation);\n    const stride = tiffHelpers_js_1.getStrideForIdf();\n    do {\n        const LOCAL_OFFSET = 0;\n        view = moveToIdfCount(offset, adjust);\n        const count = readIdfCount(view, isBigEndian);\n        const end = tiffHelpers_js_1.endIndexForIdf(0, count);\n        const bufferSize = getMinimumBufferSizeRequired(end);\n        view = adjust(offset, bufferSize);\n        const begin = tiffHelpers_js_1.beginIndexForIdf(LOCAL_OFFSET);\n        for (let i = begin; i < end; i += stride) {\n            tiffHelpers_js_1.extractIdfEntry(tags, view, i, isBigEndian);\n        }\n        // MOVE NEXT\n        const nextOffset = tiffHelpers_js_1.getIdfOffset(view, isBigEndian, end);\n        // console.log('nextOffset', nextOffset);\n        offset = nextOffset;\n    } while (offset !== 0);\n    // console.log(JSON.stringify(tags));\n    return tiffHelpers_js_1.intoResult(tags);\n}\nexports.default = viewTiffImage;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(880);\n"],"sourceRoot":""}