{"version":3,"sources":["webpack://view-image-size/./src/detectImageType.ts","webpack://view-image-size/./src/firstBytes.ts","webpack://view-image-size/./src/index.ts","webpack://view-image-size/./src/lookup.ts","webpack://view-image-size/./src/readUInt.ts","webpack://view-image-size/./src/toHexadecimal.ts","webpack://view-image-size/./src/types/bmp.ts","webpack://view-image-size/./src/types/cur.ts","webpack://view-image-size/./src/types/dds.ts","webpack://view-image-size/./src/types/gif.ts","webpack://view-image-size/./src/types/icns.ts","webpack://view-image-size/./src/types/ico.ts","webpack://view-image-size/./src/types/isEXIFAppMarker.ts","webpack://view-image-size/./src/types/j2c.ts","webpack://view-image-size/./src/types/jp2.ts","webpack://view-image-size/./src/types/jpg.ts","webpack://view-image-size/./src/types/ktx.ts","webpack://view-image-size/./src/types/png.ts","webpack://view-image-size/./src/types/pnm.ts","webpack://view-image-size/./src/types/psd.ts","webpack://view-image-size/./src/types/readJpgBlockLength.ts","webpack://view-image-size/./src/types/specificHandlers.ts","webpack://view-image-size/./src/types/svg.ts","webpack://view-image-size/./src/types/tiff.ts","webpack://view-image-size/./src/types/tiffHelpers.ts","webpack://view-image-size/./src/types/typeHandlers.ts","webpack://view-image-size/./src/types/validateJPG.ts","webpack://view-image-size/./src/types/webp.ts","webpack://view-image-size/./src/viewTiffImage.ts","webpack://view-image-size/webpack/bootstrap","webpack://view-image-size/webpack/startup"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","firstBytes_1","typeHandlers_1","specificHandlers_1","detectType","view","toAscii","found","handleType","byte","getUint8","default","byteType","validate","undefined","detectionByFirstByte","i","specificHandlers","length","key","loopThruSpecificHandlers","keys","viewTiffImage","isTiffBigEndian","detectImageType","imageSize","lookup_1","detectImageType_1","viewTiffImage_1","tiffHelpers_1","Error","type","isBigEndian","size","calculate","TypeError","readUInt32LE","readUInt32BE","readUInt32","readUInt16LE","readUInt16BE","readUInt16","readUInt24LE","readInt32LE","readInt16LE","offset","getInt16","getInt32","getUint32","getUint16","begin","end","output","toString","padStart","BMP","readUInt_1","buffer","height","Math","abs","width","CUR","ico_1","ICO","DDS","GIF","gifRegexp","signature","test","ICNS","ICON_TYPE_SIZE","ICON","icm4","icm8","ics4","ics8","is32","s8mk","icp4","icl4","icl8","il32","l8mk","icp5","ic11","ich4","ich8","ih32","h8mk","icp6","ic12","it32","t8mk","ic07","ic08","ic13","ic09","ic14","ic10","readImageHeader","imageOffset","imageLengthOffset","getImageSize","bufferLength","byteLength","fileLength","imageHeader","result","images","push","getSizeFromOffset","imageIndex","nbImages","imgs","shortMarker","identifierHi","identiferLo","compareEXIFIdentifier","J2C","toHexadecimal_1","JP2","parseIHDR","box","signatureLength","ftypeBoxStart","unit","calculateRREQLength","JPG","validateJPG_1","readJpgBlockLength_1","isEXIFAppMarker_1","extractSize","index","validateExifBlock","byteAlign","exifBlock","idfDirectoryEntries","directoryEntryNumber","start","blockStart","extractOrientation","validateBuffer","orientation","markerOffset","blockLength","headerOffset","KTX","PNG","pngFriedChunkName","chunkName","PNM","PNMTypes","P1","P2","P3","P4","P5","P6","P7","PF","Signatures","handlers","lines","dimensions","line","shift","split","parseInt","pam","charCodeAt","toLowerCase","includes","PSD","SVG","svgReg","extractorRegExps","root","viewbox","INCH_CM","units","in","cm","em","ex","m","mm","pc","pt","px","unitsReg","RegExp","join","parseLength","len","exec","round","Number","parseViewbox","bounds","toUtf8String","TextDecoder","decode","str","match","attrs","parseAttributes","calculateByDimensions","ratio","floor","calculateByViewbox","TIFF","signatures","fileSignature","initialLocation","getIdfOffsetLocation","tags","nextOffset","getIdfOffset","noOfEntries","getNoOfIdfEntries","beginIndexForIdf","endIndexForIdf","stride","getStrideForIdf","extractIdfEntry","intoResult","TIFF_IDF_ENTRY_STRIDE","TIFF_IDF_OFFSET_SIZE","TIFF_IDF_COUNT_STRIDE","directoryOffset","code","valueFieldOffset","bmp_1","cur_1","dds_1","gif_1","icns_1","j2c_1","jp2_1","jpg_1","ktx_1","png_1","pnm_1","psd_1","svg_1","tiff_1","webp_1","typeHandlers","bmp","cur","dds","gif","icns","ico","j2c","jp2","jpg","ktx","png","pnm","psd","svg","tiff","webp","WEBP","riffHeader","webpHeader","vp8Header","chunkHeader","extendedHeader","validEnd","calculateExtended","calculateLossy","sampleStart","calculateLossless","moveToIdfCount","pos","adjust","readIdfCount","initLocation","LOCAL_OFFSET","count","location","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst firstBytes_1 = __importDefault(require(\"./firstBytes\"));\nconst typeHandlers_1 = __importDefault(require(\"./types/typeHandlers\"));\nconst specificHandlers_1 = require(\"./types/specificHandlers\");\n/**\n * detect the image type\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {imageType | undefined} - returns image type (as string)\n **/\nconst detectType = (view, toAscii) => {\n    const detectionByFirstByte = () => {\n        const byte = view.getUint8(0);\n        if (byte in firstBytes_1.default) {\n            const byteType = firstBytes_1.default[byte];\n            if (byteType && typeHandlers_1.default[byteType].validate(view, toAscii)) {\n                return [true, byteType];\n            }\n        }\n        return [false, undefined];\n    };\n    const loopThruSpecificHandlers = () => {\n        for (let i = 0; i < specificHandlers_1.specificHandlers.length; i += 1) {\n            const key = specificHandlers_1.specificHandlers[i];\n            const handler = typeHandlers_1.default[key];\n            const specificResult = handler.validate(view, toAscii);\n            if (specificResult) {\n                return key;\n            }\n        }\n        return undefined;\n    };\n    const [found, handleType] = detectionByFirstByte();\n    if (found) {\n        return handleType;\n    }\n    else {\n        return loopThruSpecificHandlers();\n    }\n};\ndetectType.default = detectType;\nexports.default = detectType;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typeHandlers_1 = __importDefault(require(\"./types/typeHandlers\"));\nconst keys = Object.keys(typeHandlers_1.default);\n// This map helps avoid validating for every single image type\nconst firstBytes = {\n    0x38: 'psd',\n    0x42: 'bmp',\n    0x44: 'dds',\n    0x47: 'gif',\n    // 0x49: 'tiff',\n    // 0x4d: 'tiff',\n    0x52: 'webp',\n    0x69: 'icns',\n    0x89: 'png',\n    0xff: 'jpg',\n};\nexports.default = firstBytes;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.viewTiffImage = exports.isTiffBigEndian = exports.detectImageType = exports.imageSize = void 0;\nconst lookup_1 = __importDefault(require(\"./lookup\"));\nconst detectImageType_1 = __importDefault(require(\"./detectImageType\"));\nconst viewTiffImage_1 = __importDefault(require(\"./viewTiffImage\"));\nconst tiffHelpers_1 = require(\"./types/tiffHelpers\");\n/**\n * get image size and type from a DataView of buffer\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {\n *  {\n *  width: number,\n *  height: number,\n *  orientation?: number,\n *  type?: string\n * }\n * } image size\n */\nconst imageSize = (view, toAscii) => {\n    if (typeof toAscii !== 'function') {\n        throw new Error('toAscii is not a callback function');\n    }\n    // detect the file type.. don't rely on the extension\n    const type = detectImageType_1.default(view, toAscii);\n    return lookup_1.default(type, view, toAscii);\n};\nexports.imageSize = imageSize;\nexports.detectImageType = detectImageType_1.default;\nexports.isTiffBigEndian = tiffHelpers_1.isBigEndian;\nexports.viewTiffImage = viewTiffImage_1.default;\nexports.imageSize.default = exports.imageSize;\nexports.default = exports.imageSize;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typeHandlers_1 = __importDefault(require(\"./types/typeHandlers\"));\n/**\n * Return size information based on a buffer\n *\n * @param {imageType | undefined} type detector return by detectType()\n * @param {DataView} view\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {ISizeCalculationResult}\n */\nfunction lookup(type, view, toAscii) {\n    if (typeof type !== 'undefined') {\n        // find an appropriate handler for this file type\n        if (type in typeHandlers_1.default) {\n            const size = typeHandlers_1.default[type].calculate(view, toAscii);\n            if (size !== undefined) {\n                size.type = type;\n                return size;\n            }\n        }\n    }\n    // throw up, if we don't understand the image type\n    throw new TypeError('unsupported image type: ' + type);\n}\nexports.default = lookup;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readUInt32LE = exports.readUInt32BE = exports.readUInt32 = exports.readUInt16LE = exports.readUInt16BE = exports.readUInt16 = exports.readUInt24LE = exports.readInt32LE = exports.readInt16LE = void 0;\nfunction readInt16LE(view, offset) {\n    return view.getInt16(offset, true);\n}\nexports.readInt16LE = readInt16LE;\nfunction readInt32LE(view, offset) {\n    return view.getInt32(offset, true);\n}\nexports.readInt32LE = readInt32LE;\nfunction readUInt24LE(view, offset) {\n    return view.getUint32(offset, true) & 0xffffff;\n}\nexports.readUInt24LE = readUInt24LE;\nfunction readUInt16(view, offset, isBigEndian) {\n    return view.getUint16(offset, !isBigEndian);\n}\nexports.readUInt16 = readUInt16;\nfunction readUInt16BE(view, offset) {\n    return view.getUint16(offset, false);\n}\nexports.readUInt16BE = readUInt16BE;\nfunction readUInt16LE(view, offset) {\n    return view.getUint16(offset, true);\n}\nexports.readUInt16LE = readUInt16LE;\nfunction readUInt32(view, offset, isBigEndian) {\n    return view.getUint32(offset, !isBigEndian);\n}\nexports.readUInt32 = readUInt32;\nfunction readUInt32BE(view, offset) {\n    return view.getUint32(offset, false);\n}\nexports.readUInt32BE = readUInt32BE;\nfunction readUInt32LE(view, offset) {\n    return view.getUint32(offset, true);\n}\nexports.readUInt32LE = readUInt32LE;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toHexadecimal(view, begin, end) {\n    let output = '';\n    for (let i = begin; i < end; i += 1) {\n        const value = view.getUint8(i);\n        output += value.toString(16).padStart(2, '0');\n    }\n    return output;\n}\nexports.default = toHexadecimal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BMP = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nexports.BMP = {\n    validate(buffer, toAscii) {\n        return 'BM' === toAscii(buffer, 0, 2);\n    },\n    calculate(buffer) {\n        return {\n            height: Math.abs(readUInt_1.readInt32LE(buffer, 22)),\n            width: readUInt_1.readUInt32LE(buffer, 18),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CUR = void 0;\nconst ico_1 = require(\"./ico\");\nconst readUInt_1 = require(\"../readUInt\");\nconst TYPE_CURSOR = 2;\nexports.CUR = {\n    validate(buffer) {\n        if (readUInt_1.readUInt16LE(buffer, 0) !== 0) {\n            return false;\n        }\n        return readUInt_1.readUInt16LE(buffer, 2) === TYPE_CURSOR;\n    },\n    calculate(buffer, toAscii) {\n        return ico_1.ICO.calculate(buffer, toAscii);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDS = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nexports.DDS = {\n    validate(buffer) {\n        return readUInt_1.readUInt32LE(buffer, 0) === 0x20534444;\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32LE(buffer, 12),\n            width: readUInt_1.readUInt32LE(buffer, 16),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GIF = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst gifRegexp = /^GIF8[79]a/;\nexports.GIF = {\n    validate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 6);\n        return gifRegexp.test(signature);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt16LE(buffer, 8),\n            width: readUInt_1.readUInt16LE(buffer, 6),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICNS = void 0;\nconst readUInt_1 = require(\"../readUInt\");\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n */\nconst SIZE_HEADER = 4 + 4; // 8\nconst FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n */\nconst ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\nconst ICON_TYPE_SIZE = {\n    ICON: 32,\n    'ICN#': 32,\n    // m => 16 x 16\n    'icm#': 16,\n    icm4: 16,\n    icm8: 16,\n    // s => 16 x 16\n    'ics#': 16,\n    ics4: 16,\n    ics8: 16,\n    is32: 16,\n    s8mk: 16,\n    icp4: 16,\n    // l => 32 x 32\n    icl4: 32,\n    icl8: 32,\n    il32: 32,\n    l8mk: 32,\n    icp5: 32,\n    ic11: 32,\n    // h => 48 x 48\n    ich4: 48,\n    ich8: 48,\n    ih32: 48,\n    h8mk: 48,\n    // . => 64 x 64\n    icp6: 64,\n    ic12: 32,\n    // t => 128 x 128\n    it32: 128,\n    t8mk: 128,\n    ic07: 128,\n    // . => 256 x 256\n    ic08: 256,\n    ic13: 256,\n    // . => 512 x 512\n    ic09: 512,\n    ic14: 512,\n    // . => 1024 x 1024\n    ic10: 1024,\n};\nfunction readImageHeader(buffer, imageOffset, toAscii) {\n    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n    return [\n        toAscii(buffer, imageOffset, imageLengthOffset),\n        readUInt_1.readUInt32BE(buffer, imageLengthOffset),\n    ];\n}\nfunction getImageSize(type) {\n    const size = ICON_TYPE_SIZE[type];\n    return { width: size, height: size, type };\n}\nexports.ICNS = {\n    validate(buffer, toAscii) {\n        return 'icns' === toAscii(buffer, 0, 4);\n    },\n    calculate(buffer, toAscii) {\n        const bufferLength = buffer.byteLength;\n        const fileLength = readUInt_1.readUInt32BE(buffer, FILE_LENGTH_OFFSET);\n        let imageOffset = SIZE_HEADER;\n        let imageHeader = readImageHeader(buffer, imageOffset, toAscii);\n        let imageSize = getImageSize(imageHeader[0]);\n        imageOffset += imageHeader[1];\n        if (imageOffset === fileLength) {\n            return imageSize;\n        }\n        const result = {\n            height: imageSize.height,\n            images: [imageSize],\n            width: imageSize.width,\n        };\n        while (imageOffset < fileLength && imageOffset < bufferLength) {\n            imageHeader = readImageHeader(buffer, imageOffset, toAscii);\n            imageSize = getImageSize(imageHeader[0]);\n            imageOffset += imageHeader[1];\n            result.images.push(imageSize);\n        }\n        return result;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICO = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst TYPE_ICON = 1;\n/**\n * ICON Header\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 2    | Reserved. Must always be 0.  |\n * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |\n * | 4      | 2    | Number of images in the file. |\n *\n */\nconst SIZE_HEADER = 2 + 2 + 2; // 6\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |\n * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |\n * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |\n * | 3      | 1    | Reserved. Should be 0. |\n * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |\n * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |\n * | 6      | 2    | ICO format: Bits per pixel. |\n * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |\n * | 8      | 4    | The size of the image's data in bytes |\n * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |\n *\n */\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16\nfunction getSizeFromOffset(buffer, offset) {\n    const value = buffer.getUint8(offset);\n    return value === 0 ? 256 : value;\n}\nfunction getImageSize(buffer, imageIndex) {\n    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;\n    return {\n        height: getSizeFromOffset(buffer, offset + 1),\n        width: getSizeFromOffset(buffer, offset),\n    };\n}\nexports.ICO = {\n    validate(buffer) {\n        if (readUInt_1.readUInt16LE(buffer, 0) !== 0) {\n            return false;\n        }\n        return readUInt_1.readUInt16LE(buffer, 2) === TYPE_ICON;\n    },\n    calculate(buffer, toAscii) {\n        const nbImages = readUInt_1.readUInt16LE(buffer, 4);\n        const imageSize = getImageSize(buffer, 0);\n        if (nbImages === 1) {\n            return imageSize;\n        }\n        const imgs = [imageSize];\n        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n            imgs.push(getImageSize(buffer, imageIndex));\n        }\n        const result = {\n            height: imageSize.height,\n            images: imgs,\n            width: imageSize.width,\n        };\n        return result;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst readUInt_1 = require(\"../readUInt\");\nconst EXIF_MARKER_HI_UINT32_BE = 1165519206;\nconst EXIF_MARKER_LO_UINT16_BE = 0;\nconst compareEXIFIdentifier = (view, offset) => {\n    const identifierHi = readUInt_1.readUInt32BE(view, offset);\n    const identiferLo = readUInt_1.readUInt16BE(view, offset + 4);\n    // console.log('=identifier', identifierHi, identiferLo)\n    return (identifierHi === EXIF_MARKER_HI_UINT32_BE &&\n        identiferLo === EXIF_MARKER_LO_UINT16_BE);\n};\nfunction isEXIFAppMarker(view, shortMarker, offset) {\n    // console.log('@identifier', offset);\n    if (shortMarker == 0xffe1) {\n        const flag = compareEXIFIdentifier(view, offset);\n        // const identifer = toAscii(view, offset, offset + 6);\n        // console.log('=identifier', identifer, flag);\n        return flag;\n    }\n    else {\n        return false;\n    }\n}\nexports.default = isEXIFAppMarker;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.J2C = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nexports.J2C = {\n    validate(buffer) {\n        // TODO: this doesn't seem right. SIZ marker doesnt have to be right after the SOC\n        return toHexadecimal_1.default(buffer, 0, 4) === 'ff4fff51';\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32BE(buffer, 12),\n            width: readUInt_1.readUInt32BE(buffer, 8),\n        };\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JP2 = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nconst BoxTypes = {\n    ftyp: '66747970',\n    ihdr: '69686472',\n    jp2h: '6a703268',\n    jp__: '6a502020',\n    rreq: '72726571',\n    xml_: '786d6c20',\n};\nconst calculateRREQLength = (box, begin) => {\n    const unit = box.getUint8(begin);\n    let offset = begin + 1 + 2 * unit;\n    const numStdFlags = readUInt_1.readUInt16BE(box, offset);\n    const flagsLength = numStdFlags * (2 + unit);\n    offset = offset + 2 + flagsLength;\n    const numVendorFeatures = readUInt_1.readUInt16BE(box, offset);\n    const featuresLength = numVendorFeatures * (16 + unit);\n    return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box, offset) => {\n    return {\n        height: readUInt_1.readUInt32BE(box, offset + 4),\n        width: readUInt_1.readUInt32BE(box, offset + 8),\n    };\n};\nexports.JP2 = {\n    validate(buffer) {\n        const signature = toHexadecimal_1.default(buffer, 4, 8);\n        const signatureLength = readUInt_1.readUInt32BE(buffer, 0);\n        if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n            return false;\n        }\n        const ftypeBoxStart = signatureLength + 4;\n        // const ftypBoxLength = readUInt32BE(buffer, signatureLength)\n        // const ftypBox = buffer.buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength)\n        return (toHexadecimal_1.default(buffer, ftypeBoxStart, ftypeBoxStart + 4) === BoxTypes.ftyp);\n    },\n    calculate(buffer, toAscii) {\n        const signatureLength = readUInt_1.readUInt32BE(buffer, 0);\n        const ftypBoxLength = readUInt_1.readUInt16BE(buffer, signatureLength + 2);\n        let offset = signatureLength + 4 + ftypBoxLength;\n        const nextBoxType = toHexadecimal_1.default(buffer, offset, offset + 4);\n        switch (nextBoxType) {\n            case BoxTypes.rreq:\n                // WHAT ARE THESE 4 BYTES?????\n                // eslint-disable-next-line no-case-declarations\n                const MAGIC = 4;\n                offset = offset + 4 + MAGIC + calculateRREQLength(buffer, offset + 4);\n                return parseIHDR(buffer, offset + 8);\n            case BoxTypes.jp2h:\n                return parseIHDR(buffer, offset + 8);\n            default:\n                throw new TypeError('Unsupported header found: ' + toAscii(buffer, offset, offset + 4));\n        }\n    },\n};\n","\"use strict\";\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JPG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nconst validateJPG_1 = __importDefault(require(\"./validateJPG\"));\nconst readJpgBlockLength_1 = __importDefault(require(\"./readJpgBlockLength\"));\nconst isEXIFAppMarker_1 = __importDefault(require(\"./isEXIFAppMarker\"));\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\n// function isEXIF(buffer: DataView, offset: number): boolean {\n//   return toHexadecimal(buffer, offset + 2, offset + 6) === EXIF_MARKER;\n// }\nfunction extractSize(buffer, index) {\n    return {\n        height: readUInt_1.readUInt16BE(buffer, index),\n        width: readUInt_1.readUInt16BE(buffer, index + 2),\n    };\n}\nfunction extractOrientation(exifBlock, begin, isBigEndian) {\n    // TODO: assert that this contains 0x002A\n    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n    const idfOffset = 8;\n    // IDF osset works from right after the header bytes\n    // (so the offset includes the tiff byte align)\n    const offset = begin + EXIF_HEADER_BYTES + idfOffset;\n    const idfDirectoryEntries = readUInt_1.readUInt16(exifBlock, offset, isBigEndian);\n    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n        const start = offset +\n            NUM_DIRECTORY_ENTRIES_BYTES +\n            directoryEntryNumber * IDF_ENTRY_BYTES;\n        const end = start + IDF_ENTRY_BYTES;\n        // Skip on corrupt EXIF blocks\n        if (start > exifBlock.byteLength) {\n            return;\n        }\n        // const block = exifBlock.slice(start, end)\n        const blockStart = start;\n        const tagNumber = readUInt_1.readUInt16(exifBlock, blockStart, isBigEndian);\n        // 0x0112 (decimal: 274) is the `orientation` tag ID\n        if (tagNumber === 274) {\n            const dataFormat = readUInt_1.readUInt16(exifBlock, blockStart + 2, isBigEndian);\n            if (dataFormat !== 3) {\n                return;\n            }\n            // unsinged int has 2 bytes per component\n            // if there would more than 4 bytes in total it's a pointer\n            const numberOfComponents = readUInt_1.readUInt32(exifBlock, blockStart + 4, isBigEndian);\n            if (numberOfComponents !== 1) {\n                return;\n            }\n            return readUInt_1.readUInt16(exifBlock, blockStart + 8, isBigEndian);\n        }\n    }\n}\nfunction validateExifBlock(buffer, index) {\n    // Skip APP1 Data Size\n    // const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index)\n    const start = index;\n    // Consider byte alignment\n    // const byteAlign = toHexadecimal(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES)\n    const byteAlign = toHexadecimal_1.default(buffer, index + EXIF_HEADER_BYTES, index + EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n    // Ignore Empty EXIF. Validate byte alignment\n    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n    if (isBigEndian || isLittleEndian) {\n        return extractOrientation(buffer, index, isBigEndian);\n    }\n}\nfunction validateBuffer(buffer, index) {\n    // index should be within buffer limits\n    if (index > buffer.byteLength) {\n        throw new TypeError(`Corrupt JPG index (${index}), exceeded buffer limits (${buffer.byteLength})`);\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (buffer.getUint8(index) !== 0xff) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\nconst readMarker = (view, index) => {\n    return readUInt_1.readUInt16BE(view, index);\n};\nexports.JPG = {\n    validate(buffer) {\n        const markerShort = validateJPG_1.default(buffer); // SOI\n        return markerShort === 'ffd8';\n    },\n    calculate(buffer, toAscii) {\n        // Skip 2 bytes, first is SOI\n        let offset = 2;\n        let orientation;\n        let next;\n        while (offset < buffer.byteLength) {\n            // or EOI 0xffD9\n            // console.log('@shortMarker', offset)\n            const shortMarker = readMarker(buffer, offset);\n            // console.log('=shortMarker ', shortMarker.toString(16));\n            let markerOffset = offset + 2;\n            // console.log('@blockLength', markerOffset)\n            const blockLength = readJpgBlockLength_1.default(buffer, markerOffset);\n            // console.log('=blockLength', blockLength)\n            const headerOffset = markerOffset + 2;\n            if (isEXIFAppMarker_1.default(buffer, shortMarker, headerOffset)) {\n                // console.log('EXIF HERE')\n                const EXIF_IDENTIFIER_ID_LEN = 6;\n                orientation = validateExifBlock(buffer, headerOffset + EXIF_IDENTIFIER_ID_LEN);\n                // console.log('orientation', orientation);\n            }\n            // ensure correct format\n            validateBuffer(buffer, offset);\n            // 0xFFC0 is baseline standard(SOF)\n            // 0xFFC1 is baseline optimized(SOF)\n            // 0xFFC2 is progressive(SOF2)\n            // next = buffer.getUint8(i + 1);\n            if (shortMarker === 0xffc0 ||\n                shortMarker === 0xffc1 ||\n                shortMarker === 0xffc2) {\n                // https://www.ccoderun.ca/programming/2017-01-31_jpeg/\n                const size = extractSize(buffer, markerOffset + 3);\n                // TODO: is orientation=0 a valid answer here?\n                if (!orientation) {\n                    return size;\n                }\n                return {\n                    height: size.height,\n                    orientation,\n                    width: size.width,\n                };\n            }\n            // move to the next block\n            offset = markerOffset + blockLength;\n            // buffer = buffer.slice(i + 2)\n        }\n        throw new TypeError('Invalid JPG, no size found');\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KTX = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst SIGNATURE = 'KTX 11';\nexports.KTX = {\n    validate(buffer, toAscii) {\n        return SIGNATURE === toAscii(buffer, 1, 7);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32LE(buffer, 40),\n            width: readUInt_1.readUInt32LE(buffer, 36),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst pngSignature = 'PNG\\r\\n\\x1a\\n';\nconst pngImageHeaderChunkName = 'IHDR';\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nconst pngFriedChunkName = 'CgBI';\nexports.PNG = {\n    validate(buffer, toAscii) {\n        if (pngSignature === toAscii(buffer, 1, 8)) {\n            let chunkName = toAscii(buffer, 12, 16);\n            if (chunkName === pngFriedChunkName) {\n                chunkName = toAscii(buffer, 28, 32);\n            }\n            if (chunkName !== pngImageHeaderChunkName) {\n                throw new TypeError('Invalid PNG');\n            }\n            return true;\n        }\n        return false;\n    },\n    calculate(buffer, toAscii) {\n        if (toAscii(buffer, 12, 16) === pngFriedChunkName) {\n            return {\n                height: readUInt_1.readUInt32BE(buffer, 36),\n                width: readUInt_1.readUInt32BE(buffer, 32),\n            };\n        }\n        return {\n            height: readUInt_1.readUInt32BE(buffer, 20),\n            width: readUInt_1.readUInt32BE(buffer, 16),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNM = void 0;\nconst PNMTypes = {\n    P1: 'pbm/ascii',\n    P2: 'pgm/ascii',\n    P3: 'ppm/ascii',\n    P4: 'pbm',\n    P5: 'pgm',\n    P6: 'ppm',\n    P7: 'pam',\n    PF: 'pfm',\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n    default: (lines) => {\n        let dimensions = [];\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line[0] === '#') {\n                continue;\n            }\n            dimensions = line.split(' ');\n            break;\n        }\n        if (dimensions.length === 2) {\n            return {\n                height: parseInt(dimensions[1], 10),\n                width: parseInt(dimensions[0], 10),\n            };\n        }\n        else {\n            throw new TypeError('Invalid PNM');\n        }\n    },\n    pam: (lines) => {\n        const size = {};\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line.length > 16 || line.charCodeAt(0) > 128) {\n                continue;\n            }\n            const [key, value] = line.split(' ');\n            if (key && value) {\n                size[key.toLowerCase()] = parseInt(value, 10);\n            }\n            if (size.height && size.width) {\n                break;\n            }\n        }\n        if (size.height && size.width) {\n            return {\n                height: size.height,\n                width: size.width,\n            };\n        }\n        else {\n            throw new TypeError('Invalid PAM');\n        }\n    },\n};\nexports.PNM = {\n    validate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 2);\n        return Signatures.includes(signature);\n    },\n    calculate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 2);\n        const type = PNMTypes[signature];\n        // TODO: this probably generates garbage. move to a stream based parser\n        // const lines = buffer.toString('ascii', 3).split(/[\\r\\n]+/)\n        const lines = toAscii(buffer, 3, buffer.byteLength).split(/[\\r\\n]+/);\n        const handler = handlers[type] || handlers.default;\n        return handler(lines);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PSD = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nexports.PSD = {\n    validate(buffer, toAscii) {\n        return '8BPS' === toAscii(buffer, 0, 4);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32BE(buffer, 14),\n            width: readUInt_1.readUInt32BE(buffer, 18),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst readUInt_1 = require(\"../readUInt\");\nfunction readJpgBlockLength(view, offset) {\n    // read length of the next block\n    return readUInt_1.readUInt16BE(view, offset);\n}\nexports.default = readJpgBlockLength;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.specificHandlers = void 0;\n// [\"cur\", \"ico\", \"j2c\", \"jp2\", \"ktx\", \"pnm\", \"svg\"]\n// every image handler not covered by the first byte lookup\nexports.specificHandlers = [\n    'cur',\n    'ico',\n    'j2c',\n    'jp2',\n    'ktx',\n    'pnm',\n    'svg',\n    'tiff',\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SVG = void 0;\nconst svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n    height: /\\sheight=(['\"])([^%]+?)\\1/,\n    root: svgReg,\n    viewbox: /\\sviewBox=(['\"])(.+?)\\1/i,\n    width: /\\swidth=(['\"])([^%]+?)\\1/,\n};\nconst INCH_CM = 2.54;\nconst units = {\n    in: 96,\n    cm: 96 / INCH_CM,\n    em: 16,\n    ex: 8,\n    m: (96 / INCH_CM) * 100,\n    mm: 96 / INCH_CM / 10,\n    pc: 96 / 72 / 12,\n    pt: 96 / 72,\n    px: 1,\n};\nconst unitsReg = new RegExp(`^([0-9.]+(?:e\\\\d+)?)(${Object.keys(units).join('|')})?$`);\nfunction parseLength(len) {\n    const m = unitsReg.exec(len);\n    if (!m) {\n        return undefined;\n    }\n    return Math.round(Number(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n    const bounds = viewbox.split(' ');\n    return {\n        height: parseLength(bounds[3]),\n        width: parseLength(bounds[2]),\n    };\n}\nfunction parseAttributes(root) {\n    const width = root.match(extractorRegExps.width);\n    const height = root.match(extractorRegExps.height);\n    const viewbox = root.match(extractorRegExps.viewbox);\n    return {\n        height: height && parseLength(height[2]),\n        viewbox: viewbox && parseViewbox(viewbox[2]),\n        width: width && parseLength(width[2]),\n    };\n}\nfunction calculateByDimensions(attrs) {\n    return {\n        height: attrs.height,\n        width: attrs.width,\n    };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n    const ratio = viewbox.width / viewbox.height;\n    if (attrs.width) {\n        return {\n            height: Math.floor(attrs.width / ratio),\n            width: attrs.width,\n        };\n    }\n    if (attrs.height) {\n        return {\n            height: attrs.height,\n            width: Math.floor(attrs.height * ratio),\n        };\n    }\n    return {\n        height: viewbox.height,\n        width: viewbox.width,\n    };\n}\nfunction toUtf8String(view) {\n    const decoder = new TextDecoder('utf8');\n    return decoder.decode(view);\n}\nexports.SVG = {\n    validate(buffer) {\n        const str = toUtf8String(buffer);\n        return svgReg.test(str);\n    },\n    calculate(buffer) {\n        const root = toUtf8String(buffer).match(extractorRegExps.root);\n        if (root) {\n            const attrs = parseAttributes(root[0]);\n            if (attrs.width && attrs.height) {\n                return calculateByDimensions(attrs);\n            }\n            if (attrs.viewbox) {\n                return calculateByViewbox(attrs, attrs.viewbox);\n            }\n        }\n        throw new TypeError('Invalid SVG');\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TIFF = void 0;\nrequire(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nconst tiffHelpers_1 = require(\"./tiffHelpers\");\nconst signatures = [\n    // '492049', // currently not supported\n    '49492a00',\n    '4d4d002a', // Big Endian\n    // '4d4d002a', // BigTIFF > 4GB. currently not supported\n];\nexports.TIFF = {\n    validate(view, toAscii) {\n        const fileSignature = toHexadecimal_1.default(view, 0, 4);\n        // console.log('file sig', fileSignature);\n        return signatures.includes(fileSignature);\n    },\n    calculate(view, toAscii) {\n        // Determine BE/LE\n        const initialLocation = tiffHelpers_1.getIdfOffsetLocation();\n        const isBigEndian = tiffHelpers_1.isBigEndian(view, toAscii, initialLocation);\n        // read the IFD\n        const ifdOffset = tiffHelpers_1.getIdfOffset(view, isBigEndian);\n        // extract the tags from the IFD\n        const tags = {};\n        let nextOffset = ifdOffset;\n        do {\n            const noOfEntries = tiffHelpers_1.getNoOfIdfEntries(view, nextOffset, isBigEndian);\n            const start = tiffHelpers_1.beginIndexForIdf(nextOffset);\n            const end = tiffHelpers_1.endIndexForIdf(nextOffset, noOfEntries);\n            const stride = tiffHelpers_1.getStrideForIdf();\n            for (let i = start; i < end; i += stride) {\n                tiffHelpers_1.extractIdfEntry(tags, view, i, isBigEndian);\n            }\n            nextOffset = tiffHelpers_1.getIdfOffset(view, isBigEndian, end);\n        } while (nextOffset !== 0);\n        return tiffHelpers_1.intoResult(tags);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intoResult = exports.extractIdfEntry = exports.endIndexForIdf = exports.getStrideForIdf = exports.beginIndexForIdf = exports.TIFF_IDF_ENTRY_STRIDE = exports.TIFF_IDF_OFFSET_SIZE = exports.TIFF_IDF_COUNT_STRIDE = exports.getNoOfIdfEntries = exports.getIdfOffset = exports.getIdfOffsetLocation = exports.isBigEndian = void 0;\nconst readUInt_1 = require(\"../readUInt\");\n// Test if the TIFF is Big Endian or Little Endian\nfunction isBigEndian(view, toAscii, offset) {\n    const signature = toAscii(view, offset, 2);\n    if ('II' === signature) {\n        return false;\n    }\n    else if ('MM' === signature) {\n        return true;\n    }\n    else {\n        throw new TypeError(`Tiff endian error - ${signature}`);\n    }\n}\nexports.isBigEndian = isBigEndian;\nconst TIFF_FILE_DEFAULT = 4;\nfunction getIdfOffsetLocation() {\n    return TIFF_FILE_DEFAULT;\n}\nexports.getIdfOffsetLocation = getIdfOffsetLocation;\nfunction getIdfOffset(view, isBigEndian, offset = TIFF_FILE_DEFAULT) {\n    return readUInt_1.readUInt32(view, offset, isBigEndian);\n}\nexports.getIdfOffset = getIdfOffset;\nconst SHORT_TYPE = 3;\nconst LONG_TYPE = 4;\nfunction getNoOfIdfEntries(view, offset, isBigEndian) {\n    return readUInt_1.readUInt16(view, offset, isBigEndian);\n}\nexports.getNoOfIdfEntries = getNoOfIdfEntries;\nexports.TIFF_IDF_COUNT_STRIDE = 2;\nexports.TIFF_IDF_OFFSET_SIZE = 4;\nexports.TIFF_IDF_ENTRY_STRIDE = 12;\nfunction beginIndexForIdf(offset) {\n    return offset + 2;\n}\nexports.beginIndexForIdf = beginIndexForIdf;\nfunction getStrideForIdf() {\n    return exports.TIFF_IDF_ENTRY_STRIDE;\n}\nexports.getStrideForIdf = getStrideForIdf;\nfunction endIndexForIdf(offset, noOfEntries) {\n    return offset + 2 + noOfEntries * exports.TIFF_IDF_ENTRY_STRIDE;\n}\nexports.endIndexForIdf = endIndexForIdf;\n// Extract IFD tags from TIFF metadata\nfunction extractIdfEntry(tags, view, directoryOffset, isBigEndian) {\n    const code = readUInt_1.readUInt16(view, directoryOffset + 0, isBigEndian);\n    const type = readUInt_1.readUInt16(view, directoryOffset + 2, isBigEndian);\n    const count = readUInt_1.readUInt32(view, directoryOffset + 4, isBigEndian);\n    // 256 is width, 257 is height\n    // if (code === 256 || code === 257) {\n    // singular values not arrays or string\n    if (count === 1) {\n        const valueFieldOffset = directoryOffset + 8;\n        switch (type) {\n            case SHORT_TYPE:\n                tags[code] = readUInt_1.readUInt16(view, valueFieldOffset, isBigEndian);\n                break;\n            case LONG_TYPE:\n                tags[code] = readUInt_1.readUInt32(view, valueFieldOffset, isBigEndian);\n                break;\n        }\n    }\n}\nexports.extractIdfEntry = extractIdfEntry;\nconst WIDTH_TAG = 256;\nconst HEIGHT_TAG = 257;\nfunction intoResult(tags) {\n    const width = tags[WIDTH_TAG];\n    const height = tags[HEIGHT_TAG];\n    if (!width || !height) {\n        throw new TypeError('Invalid Tiff. Missing tags');\n    }\n    return { height, width, type: 'tiff' };\n}\nexports.intoResult = intoResult;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// load all available handlers explicitely for browserify support\nconst bmp_1 = require(\"./bmp\");\nconst cur_1 = require(\"./cur\");\nconst dds_1 = require(\"./dds\");\nconst gif_1 = require(\"./gif\");\nconst icns_1 = require(\"./icns\");\nconst ico_1 = require(\"./ico\");\nconst j2c_1 = require(\"./j2c\");\nconst jp2_1 = require(\"./jp2\");\nconst jpg_1 = require(\"./jpg\");\nconst ktx_1 = require(\"./ktx\");\nconst png_1 = require(\"./png\");\nconst pnm_1 = require(\"./pnm\");\nconst psd_1 = require(\"./psd\");\nconst svg_1 = require(\"./svg\");\nconst tiff_1 = require(\"./tiff\");\nconst webp_1 = require(\"./webp\");\nconst typeHandlers = {\n    bmp: bmp_1.BMP,\n    cur: cur_1.CUR,\n    dds: dds_1.DDS,\n    gif: gif_1.GIF,\n    icns: icns_1.ICNS,\n    ico: ico_1.ICO,\n    j2c: j2c_1.J2C,\n    jp2: jp2_1.JP2,\n    jpg: jpg_1.JPG,\n    ktx: ktx_1.KTX,\n    png: png_1.PNG,\n    pnm: pnm_1.PNM,\n    psd: psd_1.PSD,\n    svg: svg_1.SVG,\n    tiff: tiff_1.TIFF,\n    webp: webp_1.WEBP,\n};\nexports.default = typeHandlers;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nfunction validateJPG(view) {\n    const SOIMarker = toHexadecimal_1.default(view, 0, 2);\n    return SOIMarker;\n}\nexports.default = validateJPG;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WEBP = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nfunction calculateExtended(buffer, offset) {\n    return {\n        height: 1 + readUInt_1.readUInt24LE(buffer, offset + 7),\n        width: 1 + readUInt_1.readUInt24LE(buffer, offset + 4),\n    };\n}\nfunction calculateLossless(buffer, offset) {\n    const a = buffer.getUint8(offset + 4);\n    const b = buffer.getUint8(offset + 3);\n    const c = buffer.getUint8(offset + 2);\n    const d = buffer.getUint8(offset + 2);\n    const e = buffer.getUint8(offset + 1);\n    return {\n        height: 1 + (((a & 0xf) << 10) | (b << 2) | ((c & 0xc0) >> 6)),\n        width: 1 + (((d & 0x3f) << 8) | e),\n    };\n}\nfunction calculateLossy(buffer, offset) {\n    // `& 0x3fff` returns the last 14 bits\n    // TO-DO: include webp scaling in the calculations\n    return {\n        height: readUInt_1.readInt16LE(buffer, offset + 8) & 0x3fff,\n        width: readUInt_1.readInt16LE(buffer, offset + 6) & 0x3fff,\n    };\n}\nexports.WEBP = {\n    validate(buffer, toAscii) {\n        const riffHeader = 'RIFF' === toAscii(buffer, 0, 4);\n        const webpHeader = 'WEBP' === toAscii(buffer, 8, 12);\n        const vp8Header = 'VP8' === toAscii(buffer, 12, 15);\n        return riffHeader && webpHeader && vp8Header;\n    },\n    calculate(buffer, toAscii) {\n        const chunkHeader = toAscii(buffer, 12, 16);\n        // const sample = buffer.slice(20, 30)\n        const sampleStart = 20;\n        // Extended webp stream signature\n        if (chunkHeader === 'VP8X') {\n            const extendedHeader = buffer.getUint8(sampleStart);\n            const validStart = (extendedHeader & 0xc0) === 0;\n            const validEnd = (extendedHeader & 0x01) === 0;\n            if (validStart && validEnd) {\n                return calculateExtended(buffer, sampleStart);\n            }\n            else {\n                // TODO: breaking change\n                throw new TypeError('Invalid WebP');\n            }\n        }\n        // Lossless webp stream signature\n        if (chunkHeader === 'VP8 ' && buffer.getUint8(sampleStart) !== 0x2f) {\n            return calculateLossy(buffer, sampleStart);\n        }\n        // Lossy webp stream signature\n        const signature = toHexadecimal_1.default(buffer, sampleStart + 3, sampleStart + 6);\n        if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n            return calculateLossless(buffer, sampleStart);\n        }\n        throw new TypeError('Invalid WebP');\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tiffHelpers_1 = require(\"./types/tiffHelpers\");\nconst moveToIdfCount = (pos, adjust) => {\n    return adjust(pos, tiffHelpers_1.TIFF_IDF_COUNT_STRIDE); // 2 bytes\n};\nconst getMinimumBufferSizeRequired = (location) => {\n    return tiffHelpers_1.TIFF_IDF_COUNT_STRIDE + location + tiffHelpers_1.TIFF_IDF_OFFSET_SIZE;\n};\nconst readIdfCount = (view, isBigEndian) => {\n    const count = tiffHelpers_1.getNoOfIdfEntries(view, 0, isBigEndian);\n    return count;\n};\nfunction viewTiffImage(isBigEndian, adjust) {\n    const tags = {};\n    // BEGINNING\n    const START_OF_FILE = 0;\n    const TIFF_HEADER_SIZE = 8;\n    // user-specified / ADJUST\n    let view = adjust(START_OF_FILE, TIFF_HEADER_SIZE);\n    let initLocation = tiffHelpers_1.getIdfOffsetLocation(); // 4\n    let offset = tiffHelpers_1.getIdfOffset(view, isBigEndian, initLocation);\n    const stride = tiffHelpers_1.getStrideForIdf();\n    do {\n        const LOCAL_OFFSET = 0;\n        view = moveToIdfCount(offset, adjust);\n        const count = readIdfCount(view, isBigEndian);\n        const end = tiffHelpers_1.endIndexForIdf(0, count);\n        const bufferSize = getMinimumBufferSizeRequired(end);\n        view = adjust(offset, bufferSize);\n        const begin = tiffHelpers_1.beginIndexForIdf(LOCAL_OFFSET);\n        for (let i = begin; i < end; i += stride) {\n            tiffHelpers_1.extractIdfEntry(tags, view, i, isBigEndian);\n        }\n        // MOVE NEXT\n        const nextOffset = tiffHelpers_1.getIdfOffset(view, isBigEndian, end);\n        // console.log('nextOffset', nextOffset);\n        offset = nextOffset;\n    } while (offset !== 0);\n    // console.log(JSON.stringify(tags));\n    return tiffHelpers_1.intoResult(tags);\n}\nexports.default = viewTiffImage;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(341);\n"],"sourceRoot":""}