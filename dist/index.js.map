{"version":3,"sources":["webpack://view-image-size/./src/detectImageType.ts","webpack://view-image-size/./src/firstBytes.ts","webpack://view-image-size/./src/index.ts","webpack://view-image-size/./src/isTiffBigEndian.ts","webpack://view-image-size/./src/lookup.ts","webpack://view-image-size/./src/readUInt.ts","webpack://view-image-size/./src/sizeOf.ts","webpack://view-image-size/./src/toHexadecimal.ts","webpack://view-image-size/./src/types/bmp.ts","webpack://view-image-size/./src/types/cur.ts","webpack://view-image-size/./src/types/dds.ts","webpack://view-image-size/./src/types/gif.ts","webpack://view-image-size/./src/types/icns.ts","webpack://view-image-size/./src/types/ico.ts","webpack://view-image-size/./src/types/isEXIFAppMarker.ts","webpack://view-image-size/./src/types/j2c.ts","webpack://view-image-size/./src/types/jp2.ts","webpack://view-image-size/./src/types/jpg.ts","webpack://view-image-size/./src/types/ktx.ts","webpack://view-image-size/./src/types/png.ts","webpack://view-image-size/./src/types/pnm.ts","webpack://view-image-size/./src/types/psd.ts","webpack://view-image-size/./src/types/readJpgBlockLength.ts","webpack://view-image-size/./src/types/specificHandlers.ts","webpack://view-image-size/./src/types/svg.ts","webpack://view-image-size/./src/types/tiff.ts","webpack://view-image-size/./src/types/tiffHelpers.ts","webpack://view-image-size/./src/types/typeHandlers.ts","webpack://view-image-size/./src/types/validateJPG.ts","webpack://view-image-size/./src/types/webp.ts","webpack://view-image-size/./src/viewTiffImage.ts","webpack://view-image-size/webpack/bootstrap","webpack://view-image-size/webpack/startup"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","firstBytes_1","typeHandlers_1","specificHandlers_1","default","view","toAscii","found","handleType","byte","getUint8","byteType","validate","undefined","detectionByFirstByte","i","specificHandlers","length","key","loopThruSpecificHandlers","keys","imageSize","isTiffBigEndian","viewTiffImage","detectImageType","sizeOf_1","detectImageType_1","enumerable","get","viewTiffImage_1","isTiffBigEndian_1","offset","signature","TypeError","type","size","calculate","readUInt32LE","readUInt32BE","readUInt32","readUInt16LE","readUInt16BE","readUInt16","readUInt24LE","readInt32LE","readInt16LE","getInt16","getInt32","getUint32","isBigEndian","getUint16","lookup_1","Error","begin","end","output","toString","padStart","BMP","readUInt_1","buffer","height","Math","abs","width","CUR","ico_1","ICO","DDS","GIF","gifRegexp","test","ICNS","ICON_TYPE_SIZE","ICON","icm4","icm8","ics4","ics8","is32","s8mk","icp4","icl4","icl8","il32","l8mk","icp5","ic11","ich4","ich8","ih32","h8mk","icp6","ic12","it32","t8mk","ic07","ic08","ic13","ic09","ic14","ic10","readImageHeader","imageOffset","imageLengthOffset","getImageSize","bufferLength","byteLength","fileLength","imageHeader","result","images","push","getSizeFromOffset","imageIndex","nbImages","imgs","shortMarker","identifierHi","identiferLo","compareEXIFIdentifier","J2C","toHexadecimal_1","JP2","parseIHDR","box","signatureLength","ftypeBoxStart","unit","calculateRREQLength","JPG","validateJPG_1","readJpgBlockLength_1","isEXIFAppMarker_1","extractSize","index","validateExifBlock","byteAlign","exifBlock","idfDirectoryEntries","directoryEntryNumber","start","blockStart","extractOrientation","validateBuffer","orientation","markerOffset","blockLength","headerOffset","KTX","PNG","pngFriedChunkName","chunkName","PNM","PNMTypes","P1","P2","P3","P4","P5","P6","P7","PF","Signatures","handlers","lines","dimensions","line","shift","split","parseInt","pam","charCodeAt","toLowerCase","includes","PSD","SVG","svgReg","extractorRegExps","root","viewbox","INCH_CM","units","in","cm","em","ex","m","mm","pc","pt","px","unitsReg","RegExp","join","parseLength","len","exec","round","Number","parseViewbox","bounds","toUtf8String","TextDecoder","decode","str","match","attrs","parseAttributes","calculateByDimensions","ratio","floor","calculateByViewbox","TIFF","tiffHelpers_1","signatures","fileSignature","initialLocation","getIdfOffsetLocation","tags","nextOffset","getIdfOffset","noOfEntries","getNoOfIdfEntries","beginIndexForIdf","endIndexForIdf","stride","getStrideForIdf","extractIdfEntry","intoResult","TIFF_IDF_ENTRY_STRIDE","TIFF_IDF_OFFSET_SIZE","TIFF_IDF_COUNT_STRIDE","directoryOffset","code","valueFieldOffset","bmp_1","cur_1","dds_1","gif_1","icns_1","j2c_1","jp2_1","jpg_1","ktx_1","png_1","pnm_1","psd_1","svg_1","tiff_1","webp_1","typeHandlers","bmp","cur","dds","gif","icns","ico","j2c","jp2","jpg","ktx","png","pnm","psd","svg","tiff","webp","WEBP","riffHeader","webpHeader","vp8Header","chunkHeader","extendedHeader","validEnd","calculateExtended","calculateLossy","sampleStart","calculateLossless","moveToIdfCount","pos","adjust","readIdfCount","initLocation","LOCAL_OFFSET","count","location","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst firstBytes_1 = __importDefault(require(\"./firstBytes\"));\nconst typeHandlers_1 = __importDefault(require(\"./types/typeHandlers\"));\nconst specificHandlers_1 = require(\"./types/specificHandlers\");\n/**\n * detect the image type\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {imageType | undefined} - returns image type (as string)\n **/\nfunction detectImageType(view, toAscii) {\n    const detectionByFirstByte = () => {\n        const byte = view.getUint8(0);\n        if (byte in firstBytes_1.default) {\n            const byteType = firstBytes_1.default[byte];\n            if (byteType && typeHandlers_1.default[byteType].validate(view, toAscii)) {\n                return [true, byteType];\n            }\n        }\n        return [false, undefined];\n    };\n    const loopThruSpecificHandlers = () => {\n        for (let i = 0; i < specificHandlers_1.specificHandlers.length; i += 1) {\n            const key = specificHandlers_1.specificHandlers[i];\n            const handler = typeHandlers_1.default[key];\n            const specificResult = handler.validate(view, toAscii);\n            if (specificResult) {\n                return key;\n            }\n        }\n        return undefined;\n    };\n    const [found, handleType] = detectionByFirstByte();\n    if (found) {\n        return handleType;\n    }\n    else {\n        return loopThruSpecificHandlers();\n    }\n}\nexports.default = detectImageType;\n;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typeHandlers_1 = __importDefault(require(\"./types/typeHandlers\"));\nconst keys = Object.keys(typeHandlers_1.default);\n// This map helps avoid validating for every single image type\nconst firstBytes = {\n    0x38: 'psd',\n    0x42: 'bmp',\n    0x44: 'dds',\n    0x47: 'gif',\n    // 0x49: 'tiff',\n    // 0x4d: 'tiff',\n    0x52: 'webp',\n    0x69: 'icns',\n    0x89: 'png',\n    0xff: 'jpg',\n};\nexports.default = firstBytes;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.imageSize = exports.isTiffBigEndian = exports.viewTiffImage = exports.detectImageType = void 0;\nconst sizeOf_1 = __importDefault(require(\"./sizeOf\"));\nvar detectImageType_1 = require(\"./detectImageType\");\nObject.defineProperty(exports, \"detectImageType\", { enumerable: true, get: function () { return __importDefault(detectImageType_1).default; } });\nvar viewTiffImage_1 = require(\"./viewTiffImage\");\nObject.defineProperty(exports, \"viewTiffImage\", { enumerable: true, get: function () { return __importDefault(viewTiffImage_1).default; } });\nvar isTiffBigEndian_1 = require(\"./isTiffBigEndian\");\nObject.defineProperty(exports, \"isTiffBigEndian\", { enumerable: true, get: function () { return __importDefault(isTiffBigEndian_1).default; } });\n/**\n * get image size and type from a DataView of buffer\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {\n *  {\n *    width: number,\n *    height: number,\n *    images: []\n *    type: string\n *  }\n * } image size\n */\nconst imageSize = (view, toAscii) => {\n    return sizeOf_1.default(view, toAscii);\n};\nexports.imageSize = imageSize;\nexports.imageSize.default = sizeOf_1.default;\nexports.default = exports.imageSize;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Test if the TIFF is Big Endian or Little Endian\nfunction isTiffBigEndian(view, toAscii, offset) {\n    const signature = toAscii(view, offset, 2);\n    if ('II' === signature) {\n        return false;\n    }\n    else if ('MM' === signature) {\n        return true;\n    }\n    else {\n        throw new TypeError(`Tiff endian error - ${signature}`);\n    }\n}\nexports.default = isTiffBigEndian;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst typeHandlers_1 = __importDefault(require(\"./types/typeHandlers\"));\n/**\n * Return size information based on a buffer\n *\n * @param {imageType | undefined} type detector return by detectType()\n * @param {DataView} view\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {ISizeCalculationResult}\n */\nfunction lookup(type, view, toAscii) {\n    if (typeof type !== 'undefined') {\n        // find an appropriate handler for this file type\n        if (type in typeHandlers_1.default) {\n            const size = typeHandlers_1.default[type].calculate(view, toAscii);\n            if (size !== undefined) {\n                size.type = type;\n                return size;\n            }\n        }\n    }\n    // throw up, if we don't understand the image type\n    throw new TypeError('unsupported image type: ' + type);\n}\nexports.default = lookup;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readUInt32LE = exports.readUInt32BE = exports.readUInt32 = exports.readUInt16LE = exports.readUInt16BE = exports.readUInt16 = exports.readUInt24LE = exports.readInt32LE = exports.readInt16LE = void 0;\nfunction readInt16LE(view, offset) {\n    return view.getInt16(offset, true);\n}\nexports.readInt16LE = readInt16LE;\nfunction readInt32LE(view, offset) {\n    return view.getInt32(offset, true);\n}\nexports.readInt32LE = readInt32LE;\nfunction readUInt24LE(view, offset) {\n    return view.getUint32(offset, true) & 0xffffff;\n}\nexports.readUInt24LE = readUInt24LE;\nfunction readUInt16(view, offset, isBigEndian) {\n    return view.getUint16(offset, !isBigEndian);\n}\nexports.readUInt16 = readUInt16;\nfunction readUInt16BE(view, offset) {\n    return view.getUint16(offset, false);\n}\nexports.readUInt16BE = readUInt16BE;\nfunction readUInt16LE(view, offset) {\n    return view.getUint16(offset, true);\n}\nexports.readUInt16LE = readUInt16LE;\nfunction readUInt32(view, offset, isBigEndian) {\n    return view.getUint32(offset, !isBigEndian);\n}\nexports.readUInt32 = readUInt32;\nfunction readUInt32BE(view, offset) {\n    return view.getUint32(offset, false);\n}\nexports.readUInt32BE = readUInt32BE;\nfunction readUInt32LE(view, offset) {\n    return view.getUint32(offset, true);\n}\nexports.readUInt32LE = readUInt32LE;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lookup_1 = __importDefault(require(\"./lookup\"));\nconst detectImageType_1 = __importDefault(require(\"./detectImageType\"));\n/**\n * get image size and type from a DataView of buffer\n *\n * @param {DataView} view - view of buffer\n * @param {function} toAscii - function to transform byte to ascii string\n * @returns {\n *  {\n *    width: number,\n *    height: number,\n *    images: []\n *    type: string\n *  }\n * } image size\n */\nfunction sizeOf(view, toAscii) {\n    if (typeof toAscii !== 'function') {\n        throw new Error('toAscii is not a callback function');\n    }\n    // detect the file type.. don't rely on the extension\n    const type = detectImageType_1.default(view, toAscii);\n    return lookup_1.default(type, view, toAscii);\n}\nexports.default = sizeOf;\n;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction toHexadecimal(view, begin, end) {\n    let output = '';\n    for (let i = begin; i < end; i += 1) {\n        const value = view.getUint8(i);\n        output += value.toString(16).padStart(2, '0');\n    }\n    return output;\n}\nexports.default = toHexadecimal;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BMP = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nexports.BMP = {\n    validate(buffer, toAscii) {\n        return 'BM' === toAscii(buffer, 0, 2);\n    },\n    calculate(buffer) {\n        return {\n            height: Math.abs(readUInt_1.readInt32LE(buffer, 22)),\n            width: readUInt_1.readUInt32LE(buffer, 18),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CUR = void 0;\nconst ico_1 = require(\"./ico\");\nconst readUInt_1 = require(\"../readUInt\");\nconst TYPE_CURSOR = 2;\nexports.CUR = {\n    validate(buffer) {\n        if (readUInt_1.readUInt16LE(buffer, 0) !== 0) {\n            return false;\n        }\n        return readUInt_1.readUInt16LE(buffer, 2) === TYPE_CURSOR;\n    },\n    calculate(buffer, toAscii) {\n        return ico_1.ICO.calculate(buffer, toAscii);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DDS = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nexports.DDS = {\n    validate(buffer) {\n        return readUInt_1.readUInt32LE(buffer, 0) === 0x20534444;\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32LE(buffer, 12),\n            width: readUInt_1.readUInt32LE(buffer, 16),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GIF = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst gifRegexp = /^GIF8[79]a/;\nexports.GIF = {\n    validate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 6);\n        return gifRegexp.test(signature);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt16LE(buffer, 8),\n            width: readUInt_1.readUInt16LE(buffer, 6),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICNS = void 0;\nconst readUInt_1 = require(\"../readUInt\");\n/**\n * ICNS Header\n *\n * | Offset | Size | Purpose                                                |\n * | 0\t    | 4    | Magic literal, must be \"icns\" (0x69, 0x63, 0x6e, 0x73) |\n * | 4      | 4    | Length of file, in bytes, msb first.                   |\n *\n */\nconst SIZE_HEADER = 4 + 4; // 8\nconst FILE_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose                                                          |\n * | 0\t    | 4    | Icon type, see OSType below.                                     |\n * | 4      | 4    | Length of data, in bytes (including type and length), msb first. |\n * | 8      | n    | Icon data                                                        |\n */\nconst ENTRY_LENGTH_OFFSET = 4; // MSB => BIG ENDIAN\nconst ICON_TYPE_SIZE = {\n    ICON: 32,\n    'ICN#': 32,\n    // m => 16 x 16\n    'icm#': 16,\n    icm4: 16,\n    icm8: 16,\n    // s => 16 x 16\n    'ics#': 16,\n    ics4: 16,\n    ics8: 16,\n    is32: 16,\n    s8mk: 16,\n    icp4: 16,\n    // l => 32 x 32\n    icl4: 32,\n    icl8: 32,\n    il32: 32,\n    l8mk: 32,\n    icp5: 32,\n    ic11: 32,\n    // h => 48 x 48\n    ich4: 48,\n    ich8: 48,\n    ih32: 48,\n    h8mk: 48,\n    // . => 64 x 64\n    icp6: 64,\n    ic12: 32,\n    // t => 128 x 128\n    it32: 128,\n    t8mk: 128,\n    ic07: 128,\n    // . => 256 x 256\n    ic08: 256,\n    ic13: 256,\n    // . => 512 x 512\n    ic09: 512,\n    ic14: 512,\n    // . => 1024 x 1024\n    ic10: 1024,\n};\nfunction readImageHeader(buffer, imageOffset, toAscii) {\n    const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;\n    return [\n        toAscii(buffer, imageOffset, imageLengthOffset),\n        readUInt_1.readUInt32BE(buffer, imageLengthOffset),\n    ];\n}\nfunction getImageSize(type) {\n    const size = ICON_TYPE_SIZE[type];\n    return { width: size, height: size, type };\n}\nexports.ICNS = {\n    validate(buffer, toAscii) {\n        return 'icns' === toAscii(buffer, 0, 4);\n    },\n    calculate(buffer, toAscii) {\n        const bufferLength = buffer.byteLength;\n        const fileLength = readUInt_1.readUInt32BE(buffer, FILE_LENGTH_OFFSET);\n        let imageOffset = SIZE_HEADER;\n        let imageHeader = readImageHeader(buffer, imageOffset, toAscii);\n        let imageSize = getImageSize(imageHeader[0]);\n        imageOffset += imageHeader[1];\n        if (imageOffset === fileLength) {\n            return imageSize;\n        }\n        const result = {\n            height: imageSize.height,\n            images: [imageSize],\n            width: imageSize.width,\n        };\n        while (imageOffset < fileLength && imageOffset < bufferLength) {\n            imageHeader = readImageHeader(buffer, imageOffset, toAscii);\n            imageSize = getImageSize(imageHeader[0]);\n            imageOffset += imageHeader[1];\n            result.images.push(imageSize);\n        }\n        return result;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ICO = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst TYPE_ICON = 1;\n/**\n * ICON Header\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 2    | Reserved. Must always be 0.  |\n * | 2      | 2    | Image type: 1 for icon (.ICO) image, 2 for cursor (.CUR) image. Other values are invalid. |\n * | 4      | 2    | Number of images in the file. |\n *\n */\nconst SIZE_HEADER = 2 + 2 + 2; // 6\n/**\n * Image Entry\n *\n * | Offset | Size | Purpose |\n * | 0\t    | 1    | Image width in pixels. Can be any number between 0 and 255. Value 0 means width is 256 pixels. |\n * | 1      | 1    | Image height in pixels. Can be any number between 0 and 255. Value 0 means height is 256 pixels. |\n * | 2      | 1    | Number of colors in the color palette. Should be 0 if the image does not use a color palette. |\n * | 3      | 1    | Reserved. Should be 0. |\n * | 4      | 2    | ICO format: Color planes. Should be 0 or 1. |\n * |        |      | CUR format: The horizontal coordinates of the hotspot in number of pixels from the left. |\n * | 6      | 2    | ICO format: Bits per pixel. |\n * |        |      | CUR format: The vertical coordinates of the hotspot in number of pixels from the top. |\n * | 8      | 4    | The size of the image's data in bytes |\n * | 12     | 4    | The offset of BMP or PNG data from the beginning of the ICO/CUR file |\n *\n */\nconst SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4; // 16\nfunction getSizeFromOffset(buffer, offset) {\n    const value = buffer.getUint8(offset);\n    return value === 0 ? 256 : value;\n}\nfunction getImageSize(buffer, imageIndex) {\n    const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;\n    return {\n        height: getSizeFromOffset(buffer, offset + 1),\n        width: getSizeFromOffset(buffer, offset),\n    };\n}\nexports.ICO = {\n    validate(buffer) {\n        if (readUInt_1.readUInt16LE(buffer, 0) !== 0) {\n            return false;\n        }\n        return readUInt_1.readUInt16LE(buffer, 2) === TYPE_ICON;\n    },\n    calculate(buffer, toAscii) {\n        const nbImages = readUInt_1.readUInt16LE(buffer, 4);\n        const imageSize = getImageSize(buffer, 0);\n        if (nbImages === 1) {\n            return imageSize;\n        }\n        const imgs = [imageSize];\n        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {\n            imgs.push(getImageSize(buffer, imageIndex));\n        }\n        const result = {\n            height: imageSize.height,\n            images: imgs,\n            width: imageSize.width,\n        };\n        return result;\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst readUInt_1 = require(\"../readUInt\");\nconst EXIF_MARKER_HI_UINT32_BE = 1165519206;\nconst EXIF_MARKER_LO_UINT16_BE = 0;\nconst compareEXIFIdentifier = (view, offset) => {\n    const identifierHi = readUInt_1.readUInt32BE(view, offset);\n    const identiferLo = readUInt_1.readUInt16BE(view, offset + 4);\n    // console.log('=identifier', identifierHi, identiferLo)\n    return (identifierHi === EXIF_MARKER_HI_UINT32_BE &&\n        identiferLo === EXIF_MARKER_LO_UINT16_BE);\n};\nfunction isEXIFAppMarker(view, shortMarker, offset) {\n    // console.log('@identifier', offset);\n    if (shortMarker == 0xffe1) {\n        const flag = compareEXIFIdentifier(view, offset);\n        // const identifer = toAscii(view, offset, offset + 6);\n        // console.log('=identifier', identifer, flag);\n        return flag;\n    }\n    else {\n        return false;\n    }\n}\nexports.default = isEXIFAppMarker;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.J2C = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nexports.J2C = {\n    validate(buffer) {\n        // TODO: this doesn't seem right. SIZ marker doesnt have to be right after the SOC\n        return toHexadecimal_1.default(buffer, 0, 4) === 'ff4fff51';\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32BE(buffer, 12),\n            width: readUInt_1.readUInt32BE(buffer, 8),\n        };\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JP2 = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nconst BoxTypes = {\n    ftyp: '66747970',\n    ihdr: '69686472',\n    jp2h: '6a703268',\n    jp__: '6a502020',\n    rreq: '72726571',\n    xml_: '786d6c20',\n};\nconst calculateRREQLength = (box, begin) => {\n    const unit = box.getUint8(begin);\n    let offset = begin + 1 + 2 * unit;\n    const numStdFlags = readUInt_1.readUInt16BE(box, offset);\n    const flagsLength = numStdFlags * (2 + unit);\n    offset = offset + 2 + flagsLength;\n    const numVendorFeatures = readUInt_1.readUInt16BE(box, offset);\n    const featuresLength = numVendorFeatures * (16 + unit);\n    return offset + 2 + featuresLength;\n};\nconst parseIHDR = (box, offset) => {\n    return {\n        height: readUInt_1.readUInt32BE(box, offset + 4),\n        width: readUInt_1.readUInt32BE(box, offset + 8),\n    };\n};\nexports.JP2 = {\n    validate(buffer) {\n        const signature = toHexadecimal_1.default(buffer, 4, 8);\n        const signatureLength = readUInt_1.readUInt32BE(buffer, 0);\n        if (signature !== BoxTypes.jp__ || signatureLength < 1) {\n            return false;\n        }\n        const ftypeBoxStart = signatureLength + 4;\n        // const ftypBoxLength = readUInt32BE(buffer, signatureLength)\n        // const ftypBox = buffer.buffer.slice(ftypeBoxStart, ftypeBoxStart + ftypBoxLength)\n        return (toHexadecimal_1.default(buffer, ftypeBoxStart, ftypeBoxStart + 4) === BoxTypes.ftyp);\n    },\n    calculate(buffer, toAscii) {\n        const signatureLength = readUInt_1.readUInt32BE(buffer, 0);\n        const ftypBoxLength = readUInt_1.readUInt16BE(buffer, signatureLength + 2);\n        let offset = signatureLength + 4 + ftypBoxLength;\n        const nextBoxType = toHexadecimal_1.default(buffer, offset, offset + 4);\n        switch (nextBoxType) {\n            case BoxTypes.rreq:\n                // WHAT ARE THESE 4 BYTES?????\n                // eslint-disable-next-line no-case-declarations\n                const MAGIC = 4;\n                offset = offset + 4 + MAGIC + calculateRREQLength(buffer, offset + 4);\n                return parseIHDR(buffer, offset + 8);\n            case BoxTypes.jp2h:\n                return parseIHDR(buffer, offset + 8);\n            default:\n                throw new TypeError('Unsupported header found: ' + toAscii(buffer, offset, offset + 4));\n        }\n    },\n};\n","\"use strict\";\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JPG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nconst validateJPG_1 = __importDefault(require(\"./validateJPG\"));\nconst readJpgBlockLength_1 = __importDefault(require(\"./readJpgBlockLength\"));\nconst isEXIFAppMarker_1 = __importDefault(require(\"./isEXIFAppMarker\"));\nconst EXIF_MARKER = '45786966';\nconst APP1_DATA_SIZE_BYTES = 2;\nconst EXIF_HEADER_BYTES = 6;\nconst TIFF_BYTE_ALIGN_BYTES = 2;\nconst BIG_ENDIAN_BYTE_ALIGN = '4d4d';\nconst LITTLE_ENDIAN_BYTE_ALIGN = '4949';\n// Each entry is exactly 12 bytes\nconst IDF_ENTRY_BYTES = 12;\nconst NUM_DIRECTORY_ENTRIES_BYTES = 2;\n// function isEXIF(buffer: DataView, offset: number): boolean {\n//   return toHexadecimal(buffer, offset + 2, offset + 6) === EXIF_MARKER;\n// }\nfunction extractSize(buffer, index) {\n    return {\n        height: readUInt_1.readUInt16BE(buffer, index),\n        width: readUInt_1.readUInt16BE(buffer, index + 2),\n    };\n}\nfunction extractOrientation(exifBlock, begin, isBigEndian) {\n    // TODO: assert that this contains 0x002A\n    // let STATIC_MOTOROLA_TIFF_HEADER_BYTES = 2\n    // let TIFF_IMAGE_FILE_DIRECTORY_BYTES = 4\n    // TODO: derive from TIFF_IMAGE_FILE_DIRECTORY_BYTES\n    const idfOffset = 8;\n    // IDF osset works from right after the header bytes\n    // (so the offset includes the tiff byte align)\n    const offset = begin + EXIF_HEADER_BYTES + idfOffset;\n    const idfDirectoryEntries = readUInt_1.readUInt16(exifBlock, offset, isBigEndian);\n    for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {\n        const start = offset +\n            NUM_DIRECTORY_ENTRIES_BYTES +\n            directoryEntryNumber * IDF_ENTRY_BYTES;\n        const end = start + IDF_ENTRY_BYTES;\n        // Skip on corrupt EXIF blocks\n        if (start > exifBlock.byteLength) {\n            return;\n        }\n        // const block = exifBlock.slice(start, end)\n        const blockStart = start;\n        const tagNumber = readUInt_1.readUInt16(exifBlock, blockStart, isBigEndian);\n        // 0x0112 (decimal: 274) is the `orientation` tag ID\n        if (tagNumber === 274) {\n            const dataFormat = readUInt_1.readUInt16(exifBlock, blockStart + 2, isBigEndian);\n            if (dataFormat !== 3) {\n                return;\n            }\n            // unsinged int has 2 bytes per component\n            // if there would more than 4 bytes in total it's a pointer\n            const numberOfComponents = readUInt_1.readUInt32(exifBlock, blockStart + 4, isBigEndian);\n            if (numberOfComponents !== 1) {\n                return;\n            }\n            return readUInt_1.readUInt16(exifBlock, blockStart + 8, isBigEndian);\n        }\n    }\n}\nfunction validateExifBlock(buffer, index) {\n    // Skip APP1 Data Size\n    // const exifBlock = buffer.slice(APP1_DATA_SIZE_BYTES, index)\n    const start = index;\n    // Consider byte alignment\n    // const byteAlign = toHexadecimal(exifBlock, EXIF_HEADER_BYTES, EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES)\n    const byteAlign = toHexadecimal_1.default(buffer, index + EXIF_HEADER_BYTES, index + EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES);\n    // Ignore Empty EXIF. Validate byte alignment\n    const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;\n    const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;\n    if (isBigEndian || isLittleEndian) {\n        return extractOrientation(buffer, index, isBigEndian);\n    }\n}\nfunction validateBuffer(buffer, index) {\n    // index should be within buffer limits\n    if (index > buffer.byteLength) {\n        throw new TypeError(`Corrupt JPG index (${index}), exceeded buffer limits (${buffer.byteLength})`);\n    }\n    // Every JPEG block must begin with a 0xFF\n    if (buffer.getUint8(index) !== 0xff) {\n        throw new TypeError('Invalid JPG, marker table corrupted');\n    }\n}\nconst readMarker = (view, index) => {\n    return readUInt_1.readUInt16BE(view, index);\n};\nexports.JPG = {\n    validate(buffer) {\n        const markerShort = validateJPG_1.default(buffer); // SOI\n        return markerShort === 'ffd8';\n    },\n    calculate(buffer, toAscii) {\n        // Skip 2 bytes, first is SOI\n        let offset = 2;\n        let orientation;\n        let next;\n        while (offset < buffer.byteLength) {\n            // or EOI 0xffD9\n            // console.log('@shortMarker', offset)\n            const shortMarker = readMarker(buffer, offset);\n            // console.log('=shortMarker ', shortMarker.toString(16));\n            let markerOffset = offset + 2;\n            // console.log('@blockLength', markerOffset)\n            const blockLength = readJpgBlockLength_1.default(buffer, markerOffset);\n            // console.log('=blockLength', blockLength)\n            const headerOffset = markerOffset + 2;\n            if (isEXIFAppMarker_1.default(buffer, shortMarker, headerOffset)) {\n                // console.log('EXIF HERE')\n                const EXIF_IDENTIFIER_ID_LEN = 6;\n                orientation = validateExifBlock(buffer, headerOffset + EXIF_IDENTIFIER_ID_LEN);\n                // console.log('orientation', orientation);\n            }\n            // ensure correct format\n            validateBuffer(buffer, offset);\n            // 0xFFC0 is baseline standard(SOF)\n            // 0xFFC1 is baseline optimized(SOF)\n            // 0xFFC2 is progressive(SOF2)\n            // next = buffer.getUint8(i + 1);\n            if (shortMarker === 0xffc0 ||\n                shortMarker === 0xffc1 ||\n                shortMarker === 0xffc2) {\n                // https://www.ccoderun.ca/programming/2017-01-31_jpeg/\n                const size = extractSize(buffer, markerOffset + 3);\n                // TODO: is orientation=0 a valid answer here?\n                if (!orientation) {\n                    return size;\n                }\n                return {\n                    height: size.height,\n                    orientation,\n                    width: size.width,\n                };\n            }\n            // move to the next block\n            offset = markerOffset + blockLength;\n            // buffer = buffer.slice(i + 2)\n        }\n        throw new TypeError('Invalid JPG, no size found');\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KTX = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst SIGNATURE = 'KTX 11';\nexports.KTX = {\n    validate(buffer, toAscii) {\n        return SIGNATURE === toAscii(buffer, 1, 7);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32LE(buffer, 40),\n            width: readUInt_1.readUInt32LE(buffer, 36),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNG = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst pngSignature = 'PNG\\r\\n\\x1a\\n';\nconst pngImageHeaderChunkName = 'IHDR';\n// Used to detect \"fried\" png's: http://www.jongware.com/pngdefry.html\nconst pngFriedChunkName = 'CgBI';\nexports.PNG = {\n    validate(buffer, toAscii) {\n        if (pngSignature === toAscii(buffer, 1, 8)) {\n            let chunkName = toAscii(buffer, 12, 16);\n            if (chunkName === pngFriedChunkName) {\n                chunkName = toAscii(buffer, 28, 32);\n            }\n            if (chunkName !== pngImageHeaderChunkName) {\n                throw new TypeError('Invalid PNG');\n            }\n            return true;\n        }\n        return false;\n    },\n    calculate(buffer, toAscii) {\n        if (toAscii(buffer, 12, 16) === pngFriedChunkName) {\n            return {\n                height: readUInt_1.readUInt32BE(buffer, 36),\n                width: readUInt_1.readUInt32BE(buffer, 32),\n            };\n        }\n        return {\n            height: readUInt_1.readUInt32BE(buffer, 20),\n            width: readUInt_1.readUInt32BE(buffer, 16),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PNM = void 0;\nconst PNMTypes = {\n    P1: 'pbm/ascii',\n    P2: 'pgm/ascii',\n    P3: 'ppm/ascii',\n    P4: 'pbm',\n    P5: 'pgm',\n    P6: 'ppm',\n    P7: 'pam',\n    PF: 'pfm',\n};\nconst Signatures = Object.keys(PNMTypes);\nconst handlers = {\n    default: (lines) => {\n        let dimensions = [];\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line[0] === '#') {\n                continue;\n            }\n            dimensions = line.split(' ');\n            break;\n        }\n        if (dimensions.length === 2) {\n            return {\n                height: parseInt(dimensions[1], 10),\n                width: parseInt(dimensions[0], 10),\n            };\n        }\n        else {\n            throw new TypeError('Invalid PNM');\n        }\n    },\n    pam: (lines) => {\n        const size = {};\n        while (lines.length > 0) {\n            const line = lines.shift();\n            if (line.length > 16 || line.charCodeAt(0) > 128) {\n                continue;\n            }\n            const [key, value] = line.split(' ');\n            if (key && value) {\n                size[key.toLowerCase()] = parseInt(value, 10);\n            }\n            if (size.height && size.width) {\n                break;\n            }\n        }\n        if (size.height && size.width) {\n            return {\n                height: size.height,\n                width: size.width,\n            };\n        }\n        else {\n            throw new TypeError('Invalid PAM');\n        }\n    },\n};\nexports.PNM = {\n    validate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 2);\n        return Signatures.includes(signature);\n    },\n    calculate(buffer, toAscii) {\n        const signature = toAscii(buffer, 0, 2);\n        const type = PNMTypes[signature];\n        // TODO: this probably generates garbage. move to a stream based parser\n        // const lines = buffer.toString('ascii', 3).split(/[\\r\\n]+/)\n        const lines = toAscii(buffer, 3, buffer.byteLength).split(/[\\r\\n]+/);\n        const handler = handlers[type] || handlers.default;\n        return handler(lines);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PSD = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nexports.PSD = {\n    validate(buffer, toAscii) {\n        return '8BPS' === toAscii(buffer, 0, 4);\n    },\n    calculate(buffer) {\n        return {\n            height: readUInt_1.readUInt32BE(buffer, 14),\n            width: readUInt_1.readUInt32BE(buffer, 18),\n        };\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst readUInt_1 = require(\"../readUInt\");\nfunction readJpgBlockLength(view, offset) {\n    // read length of the next block\n    return readUInt_1.readUInt16BE(view, offset);\n}\nexports.default = readJpgBlockLength;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.specificHandlers = void 0;\n// [\"cur\", \"ico\", \"j2c\", \"jp2\", \"ktx\", \"pnm\", \"svg\"]\n// every image handler not covered by the first byte lookup\nexports.specificHandlers = [\n    'cur',\n    'ico',\n    'j2c',\n    'jp2',\n    'ktx',\n    'pnm',\n    'svg',\n    'tiff',\n];\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SVG = void 0;\nconst svgReg = /<svg\\s([^>\"']|\"[^\"]*\"|'[^']*')*>/;\nconst extractorRegExps = {\n    height: /\\sheight=(['\"])([^%]+?)\\1/,\n    root: svgReg,\n    viewbox: /\\sviewBox=(['\"])(.+?)\\1/i,\n    width: /\\swidth=(['\"])([^%]+?)\\1/,\n};\nconst INCH_CM = 2.54;\nconst units = {\n    in: 96,\n    cm: 96 / INCH_CM,\n    em: 16,\n    ex: 8,\n    m: (96 / INCH_CM) * 100,\n    mm: 96 / INCH_CM / 10,\n    pc: 96 / 72 / 12,\n    pt: 96 / 72,\n    px: 1,\n};\nconst unitsReg = new RegExp(`^([0-9.]+(?:e\\\\d+)?)(${Object.keys(units).join('|')})?$`);\nfunction parseLength(len) {\n    const m = unitsReg.exec(len);\n    if (!m) {\n        return undefined;\n    }\n    return Math.round(Number(m[1]) * (units[m[2]] || 1));\n}\nfunction parseViewbox(viewbox) {\n    const bounds = viewbox.split(' ');\n    return {\n        height: parseLength(bounds[3]),\n        width: parseLength(bounds[2]),\n    };\n}\nfunction parseAttributes(root) {\n    const width = root.match(extractorRegExps.width);\n    const height = root.match(extractorRegExps.height);\n    const viewbox = root.match(extractorRegExps.viewbox);\n    return {\n        height: height && parseLength(height[2]),\n        viewbox: viewbox && parseViewbox(viewbox[2]),\n        width: width && parseLength(width[2]),\n    };\n}\nfunction calculateByDimensions(attrs) {\n    return {\n        height: attrs.height,\n        width: attrs.width,\n    };\n}\nfunction calculateByViewbox(attrs, viewbox) {\n    const ratio = viewbox.width / viewbox.height;\n    if (attrs.width) {\n        return {\n            height: Math.floor(attrs.width / ratio),\n            width: attrs.width,\n        };\n    }\n    if (attrs.height) {\n        return {\n            height: attrs.height,\n            width: Math.floor(attrs.height * ratio),\n        };\n    }\n    return {\n        height: viewbox.height,\n        width: viewbox.width,\n    };\n}\nfunction toUtf8String(view) {\n    const decoder = new TextDecoder('utf8');\n    return decoder.decode(view);\n}\nexports.SVG = {\n    validate(buffer) {\n        const str = toUtf8String(buffer);\n        return svgReg.test(str);\n    },\n    calculate(buffer) {\n        const root = toUtf8String(buffer).match(extractorRegExps.root);\n        if (root) {\n            const attrs = parseAttributes(root[0]);\n            if (attrs.width && attrs.height) {\n                return calculateByDimensions(attrs);\n            }\n            if (attrs.viewbox) {\n                return calculateByViewbox(attrs, attrs.viewbox);\n            }\n        }\n        throw new TypeError('Invalid SVG');\n    },\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TIFF = void 0;\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nconst isTiffBigEndian_1 = __importDefault(require(\"../isTiffBigEndian\"));\nconst tiffHelpers_1 = require(\"./tiffHelpers\");\nconst signatures = [\n    // '492049', // currently not supported\n    '49492a00',\n    '4d4d002a', // Big Endian\n    // '4d4d002a', // BigTIFF > 4GB. currently not supported\n];\nexports.TIFF = {\n    validate(view, toAscii) {\n        const fileSignature = toHexadecimal_1.default(view, 0, 4);\n        // console.log('file sig', fileSignature);\n        return signatures.includes(fileSignature);\n    },\n    calculate(view, toAscii) {\n        // Determine BE/LE\n        const initialLocation = tiffHelpers_1.getIdfOffsetLocation();\n        const isBigEndian = isTiffBigEndian_1.default(view, toAscii, initialLocation);\n        // read the IFD\n        const ifdOffset = tiffHelpers_1.getIdfOffset(view, isBigEndian);\n        // extract the tags from the IFD\n        const tags = {};\n        let nextOffset = ifdOffset;\n        do {\n            const noOfEntries = tiffHelpers_1.getNoOfIdfEntries(view, nextOffset, isBigEndian);\n            const start = tiffHelpers_1.beginIndexForIdf(nextOffset);\n            const end = tiffHelpers_1.endIndexForIdf(nextOffset, noOfEntries);\n            const stride = tiffHelpers_1.getStrideForIdf();\n            for (let i = start; i < end; i += stride) {\n                tiffHelpers_1.extractIdfEntry(tags, view, i, isBigEndian);\n            }\n            nextOffset = tiffHelpers_1.getIdfOffset(view, isBigEndian, end);\n        } while (nextOffset !== 0);\n        return tiffHelpers_1.intoResult(tags);\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.intoResult = exports.extractIdfEntry = exports.endIndexForIdf = exports.getStrideForIdf = exports.beginIndexForIdf = exports.TIFF_IDF_ENTRY_STRIDE = exports.TIFF_IDF_OFFSET_SIZE = exports.TIFF_IDF_COUNT_STRIDE = exports.getNoOfIdfEntries = exports.getIdfOffset = exports.getIdfOffsetLocation = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst TIFF_FILE_DEFAULT = 4;\nfunction getIdfOffsetLocation() {\n    return TIFF_FILE_DEFAULT;\n}\nexports.getIdfOffsetLocation = getIdfOffsetLocation;\nfunction getIdfOffset(view, isBigEndian, offset = TIFF_FILE_DEFAULT) {\n    return readUInt_1.readUInt32(view, offset, isBigEndian);\n}\nexports.getIdfOffset = getIdfOffset;\nconst SHORT_TYPE = 3;\nconst LONG_TYPE = 4;\nfunction getNoOfIdfEntries(view, offset, isBigEndian) {\n    return readUInt_1.readUInt16(view, offset, isBigEndian);\n}\nexports.getNoOfIdfEntries = getNoOfIdfEntries;\nexports.TIFF_IDF_COUNT_STRIDE = 2;\nexports.TIFF_IDF_OFFSET_SIZE = 4;\nexports.TIFF_IDF_ENTRY_STRIDE = 12;\nfunction beginIndexForIdf(offset) {\n    return offset + 2;\n}\nexports.beginIndexForIdf = beginIndexForIdf;\nfunction getStrideForIdf() {\n    return exports.TIFF_IDF_ENTRY_STRIDE;\n}\nexports.getStrideForIdf = getStrideForIdf;\nfunction endIndexForIdf(offset, noOfEntries) {\n    return offset + 2 + noOfEntries * exports.TIFF_IDF_ENTRY_STRIDE;\n}\nexports.endIndexForIdf = endIndexForIdf;\n// Extract IFD tags from TIFF metadata\nfunction extractIdfEntry(tags, view, directoryOffset, isBigEndian) {\n    const code = readUInt_1.readUInt16(view, directoryOffset + 0, isBigEndian);\n    const type = readUInt_1.readUInt16(view, directoryOffset + 2, isBigEndian);\n    const count = readUInt_1.readUInt32(view, directoryOffset + 4, isBigEndian);\n    // 256 is width, 257 is height\n    // if (code === 256 || code === 257) {\n    // singular values not arrays or string\n    if (count === 1) {\n        const valueFieldOffset = directoryOffset + 8;\n        switch (type) {\n            case SHORT_TYPE:\n                tags[code] = readUInt_1.readUInt16(view, valueFieldOffset, isBigEndian);\n                break;\n            case LONG_TYPE:\n                tags[code] = readUInt_1.readUInt32(view, valueFieldOffset, isBigEndian);\n                break;\n        }\n    }\n}\nexports.extractIdfEntry = extractIdfEntry;\nconst WIDTH_TAG = 256;\nconst HEIGHT_TAG = 257;\nfunction intoResult(tags) {\n    const width = tags[WIDTH_TAG];\n    const height = tags[HEIGHT_TAG];\n    if (!width || !height) {\n        throw new TypeError('Invalid Tiff. Missing tags');\n    }\n    return { height, width, type: 'tiff' };\n}\nexports.intoResult = intoResult;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// load all available handlers explicitely for browserify support\nconst bmp_1 = require(\"./bmp\");\nconst cur_1 = require(\"./cur\");\nconst dds_1 = require(\"./dds\");\nconst gif_1 = require(\"./gif\");\nconst icns_1 = require(\"./icns\");\nconst ico_1 = require(\"./ico\");\nconst j2c_1 = require(\"./j2c\");\nconst jp2_1 = require(\"./jp2\");\nconst jpg_1 = require(\"./jpg\");\nconst ktx_1 = require(\"./ktx\");\nconst png_1 = require(\"./png\");\nconst pnm_1 = require(\"./pnm\");\nconst psd_1 = require(\"./psd\");\nconst svg_1 = require(\"./svg\");\nconst tiff_1 = require(\"./tiff\");\nconst webp_1 = require(\"./webp\");\nconst typeHandlers = {\n    bmp: bmp_1.BMP,\n    cur: cur_1.CUR,\n    dds: dds_1.DDS,\n    gif: gif_1.GIF,\n    icns: icns_1.ICNS,\n    ico: ico_1.ICO,\n    j2c: j2c_1.J2C,\n    jp2: jp2_1.JP2,\n    jpg: jpg_1.JPG,\n    ktx: ktx_1.KTX,\n    png: png_1.PNG,\n    pnm: pnm_1.PNM,\n    psd: psd_1.PSD,\n    svg: svg_1.SVG,\n    tiff: tiff_1.TIFF,\n    webp: webp_1.WEBP,\n};\nexports.default = typeHandlers;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nfunction validateJPG(view) {\n    const SOIMarker = toHexadecimal_1.default(view, 0, 2);\n    return SOIMarker;\n}\nexports.default = validateJPG;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WEBP = void 0;\nconst readUInt_1 = require(\"../readUInt\");\nconst toHexadecimal_1 = __importDefault(require(\"../toHexadecimal\"));\nfunction calculateExtended(buffer, offset) {\n    return {\n        height: 1 + readUInt_1.readUInt24LE(buffer, offset + 7),\n        width: 1 + readUInt_1.readUInt24LE(buffer, offset + 4),\n    };\n}\nfunction calculateLossless(buffer, offset) {\n    const a = buffer.getUint8(offset + 4);\n    const b = buffer.getUint8(offset + 3);\n    const c = buffer.getUint8(offset + 2);\n    const d = buffer.getUint8(offset + 2);\n    const e = buffer.getUint8(offset + 1);\n    return {\n        height: 1 + (((a & 0xf) << 10) | (b << 2) | ((c & 0xc0) >> 6)),\n        width: 1 + (((d & 0x3f) << 8) | e),\n    };\n}\nfunction calculateLossy(buffer, offset) {\n    // `& 0x3fff` returns the last 14 bits\n    // TO-DO: include webp scaling in the calculations\n    return {\n        height: readUInt_1.readInt16LE(buffer, offset + 8) & 0x3fff,\n        width: readUInt_1.readInt16LE(buffer, offset + 6) & 0x3fff,\n    };\n}\nexports.WEBP = {\n    validate(buffer, toAscii) {\n        const riffHeader = 'RIFF' === toAscii(buffer, 0, 4);\n        const webpHeader = 'WEBP' === toAscii(buffer, 8, 12);\n        const vp8Header = 'VP8' === toAscii(buffer, 12, 15);\n        return riffHeader && webpHeader && vp8Header;\n    },\n    calculate(buffer, toAscii) {\n        const chunkHeader = toAscii(buffer, 12, 16);\n        // const sample = buffer.slice(20, 30)\n        const sampleStart = 20;\n        // Extended webp stream signature\n        if (chunkHeader === 'VP8X') {\n            const extendedHeader = buffer.getUint8(sampleStart);\n            const validStart = (extendedHeader & 0xc0) === 0;\n            const validEnd = (extendedHeader & 0x01) === 0;\n            if (validStart && validEnd) {\n                return calculateExtended(buffer, sampleStart);\n            }\n            else {\n                // TODO: breaking change\n                throw new TypeError('Invalid WebP');\n            }\n        }\n        // Lossless webp stream signature\n        if (chunkHeader === 'VP8 ' && buffer.getUint8(sampleStart) !== 0x2f) {\n            return calculateLossy(buffer, sampleStart);\n        }\n        // Lossy webp stream signature\n        const signature = toHexadecimal_1.default(buffer, sampleStart + 3, sampleStart + 6);\n        if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n            return calculateLossless(buffer, sampleStart);\n        }\n        throw new TypeError('Invalid WebP');\n    },\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tiffHelpers_1 = require(\"./types/tiffHelpers\");\nconst moveToIdfCount = (pos, adjust) => {\n    return adjust(pos, tiffHelpers_1.TIFF_IDF_COUNT_STRIDE); // 2 bytes\n};\nconst getMinimumBufferSizeRequired = (location) => {\n    return tiffHelpers_1.TIFF_IDF_COUNT_STRIDE + location + tiffHelpers_1.TIFF_IDF_OFFSET_SIZE;\n};\nconst readIdfCount = (view, isBigEndian) => {\n    const count = tiffHelpers_1.getNoOfIdfEntries(view, 0, isBigEndian);\n    return count;\n};\nfunction viewTiffImage(isBigEndian, adjust) {\n    const tags = {};\n    // BEGINNING\n    const START_OF_FILE = 0;\n    const TIFF_HEADER_SIZE = 8;\n    // user-specified / ADJUST\n    let view = adjust(START_OF_FILE, TIFF_HEADER_SIZE);\n    let initLocation = tiffHelpers_1.getIdfOffsetLocation(); // 4\n    let offset = tiffHelpers_1.getIdfOffset(view, isBigEndian, initLocation);\n    const stride = tiffHelpers_1.getStrideForIdf();\n    do {\n        const LOCAL_OFFSET = 0;\n        view = moveToIdfCount(offset, adjust);\n        const count = readIdfCount(view, isBigEndian);\n        const end = tiffHelpers_1.endIndexForIdf(0, count);\n        const bufferSize = getMinimumBufferSizeRequired(end);\n        view = adjust(offset, bufferSize);\n        const begin = tiffHelpers_1.beginIndexForIdf(LOCAL_OFFSET);\n        for (let i = begin; i < end; i += stride) {\n            tiffHelpers_1.extractIdfEntry(tags, view, i, isBigEndian);\n        }\n        // MOVE NEXT\n        const nextOffset = tiffHelpers_1.getIdfOffset(view, isBigEndian, end);\n        // console.log('nextOffset', nextOffset);\n        offset = nextOffset;\n    } while (offset !== 0);\n    // console.log(JSON.stringify(tags));\n    return tiffHelpers_1.intoResult(tags);\n}\nexports.default = viewTiffImage;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(341);\n"],"sourceRoot":""}